{
  "hash": "327aa638d0c515d6c629e859e0d28f7a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pentomino Solution & Patchwork\"\ndate: last-modified\ncategories: [r, puzzle, ggplot, ggraph, tidygraph, patchwork]\nformat:\n  html:\n    code-fold: true\n    fig-width: 9.5\n    fig-height: 6.5\nexecute:\n  echo: true\neditor_options: \n  chunk_output_type: console\nimage: images/Pentominos_flip.gif\n---\n\n\n\n### Pentomino Solution as `igraph` object\n\nIn this post, I‚Äôm taking deeper dive into a dataset of [Pentomino puzzle solutions](https://isomerdesign.com/Pentomino/) using R.  This time, I‚Äôm switching gears from the [sf](https://r-spatial.github.io/sf/) package, but to explore graph theory concepts with [tidygraph](https://tidygraph.data-imaginist.com/reference/index.html) and [ggraph](https://ggraph.data-imaginist.com/). Why? Because Pentomino solutions aren‚Äôt just puzzles; they‚Äôre networks waiting to be uncovered! üåê\n\nWhat's on the menu? üç¥\n\n- Data Wrangling with [tidyverse](https://www.tidyverse.org/) \n- Graphs and graph-based data structures with [tidygraph](https://tidygraph.data-imaginist.com/reference/index.html) and visualization with  [ggraph](https://ggraph.data-imaginist.com/) \n- Arranging Multiple Plots effortlessly with [`patchwork`](https://patchwork.data-imaginist.com/index.html). The [wrap_plots() function](https://patchwork.data-imaginist.com/reference/wrap_plots.html) function was a lifesaver, sparing me from the monotony of typing plot1 + plot2 + ... repeatedly! üôå \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Setups and Pakcages Used\"}\n# Load required libraries\nlibrary(tidyverse)    # Data wrangling and general utilities\nlibrary(ggraph)       # Graph visualization\nlibrary(tidygraph)    # Graph data structure (tbl_graph) + graph algorithms\nlibrary(ggforce)      # Extra geoms for ggplot2\nlibrary(cowplot)      # Additional plotting helpers\nlibrary(patchwork)    # Combine multiple ggplots effortlessly!\n```\n:::\n\n\n\n\n### Original Solution Dataset \n\nI've saved solution as csv file from earlier blog posts.  So just retriving the dataset. \nSolution looks like below.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Reading Solution Dataset\"}\n### Read solution data frame from Github \npento_sol <- read_csv(\"https://raw.githubusercontent.com/chichacha/pentomino/refs/heads/main/pentomino_solution.csv\")\n\nsample_n(pento_sol, size=5) |>\n  knitr::kable(\"markdown\")\n```\n\n::: {.cell-output-display}\n\n\n|dim  |sol_text                                                                | row_cnt| col_cnt| sol_idx|\n|:----|:-----------------------------------------------------------------------|-------:|-------:|-------:|\n|5√ó10 |LLLLTTTNNN UUULWTNNFF UPUWWTYFFV PPWWYYYYFV PPIIIIIVVV                  |       5|      10|    5427|\n|6√ó10 |IIIIIXYYYY VVVFXXXNYW VTFFFXNNWW VTTTFZNWWP UTUZZZNLPP UUUZLLLLPP       |       6|      10|     707|\n|5√ó9  |IIIIIFVVV UUPPFFFTV UPPPZZFTV UUNNZLTTT NNNZZLLLL                       |       5|       9|    1024|\n|8√ó8d |.FFNNNX. FFNNYXXX IFYYYYXT ILLLLTTT IVVVLWWT IVZZWWPP IVZUWUPP .ZZUUUP. |       8|       8|     133|\n|5√ó11 |LLLLFZZNTTT LXFFFVZNNTY XXXFPVZZNTY UXUPPVVVNYY UUUPPIIIIIY             |       5|      11|    2837|\n\n\n:::\n:::\n\n\n\n#### Just prepping colors\n\nTo make our graphs visually fun, I'm just using retro-inspired color palette and assign unique colors to each Pentomino piece.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Prepping Color Palette\"}\n# Just Prepping some color palette\nretro <-  c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\nretro12 <- colorRampPalette(retro)(12)\nretro13 <- c(retro12,\"#ffffff\")\n\n#Assigning names to each color allows direct mapping with scale_color_manual() or scale_fill_manual()\npiece <- c(\"F\",\"I\",\"L\",\"N\",\"P\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")\nnames(retro12) <- piece\nnames(retro13) <- c(piece,\".\")\n\nretro12 |> enframe() |>\n  ggplot(aes(x=name,y=1)) +\n  geom_tile(aes(fill=I(value))) +\n  geom_text(aes(label=name), color=\"white\",vjust=-0.5) +\n  geom_text(aes(label=value), color=\"white\",vjust=1, size=3) +\n  theme_nothing()\n```\n\n::: {.cell-output-display}\n![](pentomino_part4_files/figure-html/unnamed-chunk-3-1.png){width=921.6}\n:::\n:::\n\n\n\n### Converting Solution to (x,y) Positions üìê\n\nNext, we‚Äôll transform each solution into (x, y) coordinates. This step is crucial for graph creation.  I've listed a visualization & table of some 3x5 Pentomino solutions, mapped to their (x, y) position.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Converting Solution Texts to Data Frame with Coordinates\"}\n### Convert Solution to XY position data frame\npento_sol_df <- pento_sol |>\n  mutate(solution_num = row_number()) |>\n  mutate(sol_text = str_split(sol_text, \" \")) |>\n  unnest(sol_text) |>\n  group_by(solution_num) |>\n  mutate(y = row_number()) |>\n  ungroup() |>\n  mutate(sol_text = str_split(sol_text, \"\")) |>\n  unnest(sol_text) |>\n  group_by(solution_num, y) |>\n  mutate(x = row_number()) |>\n  ungroup()\n\n\n# Split the data into chunks programmatically\ntables <- pento_sol_df |> \n  filter(dim == \"5√ó3\", sol_idx == 1) |>\n  select(dim, sol_text, x, y) |>\n  group_split(x)\n\npento_sol_df |> \n  filter(dim == \"5√ó3\", sol_idx %in% c(1:6)) |>\n  mutate(sol_idx=if_else(sol_idx==1, str_c(\"1. See Table Below\"), as.character(sol_idx))) |>\n  ggplot(aes(x=x,y=y)) +\n  geom_point(aes(color=sol_text),size=10) +\n  geom_text(aes(label=sol_text), color=\"#fffff3\") +\n  scale_color_manual(values=retro12, guide=\"none\") +\n  theme_minimal() +\n  facet_wrap(~sol_idx,ncol=6) +\n  coord_fixed() +\n  scale_x_continuous(expand=expansion(add=1)) +\n  scale_y_continuous(expand=expansion(add=1))\n```\n\n::: {.cell-output-display}\n![](pentomino_part4_files/figure-html/unnamed-chunk-4-1.png){width=921.6}\n:::\n:::\n\n\n\n::: {#tbl-panel layout-ncol=3}\n\n\n|dim |sol_text |  x|  y|\n|:---|:--------|--:|--:|\n|5√ó3 |L        |  1|  1|\n|5√ó3 |L        |  1|  2|\n|5√ó3 |L        |  1|  3|\n|5√ó3 |L        |  1|  4|\n|5√ó3 |V        |  1|  5|\n\n\n\n\n|dim |sol_text |  x|  y|\n|:---|:--------|--:|--:|\n|5√ó3 |L        |  2|  1|\n|5√ó3 |N        |  2|  2|\n|5√ó3 |N        |  2|  3|\n|5√ó3 |N        |  2|  4|\n|5√ó3 |V        |  2|  5|\n\n\n\n\n|dim |sol_text |  x|  y|\n|:---|:--------|--:|--:|\n|5√ó3 |N        |  3|  1|\n|5√ó3 |N        |  3|  2|\n|5√ó3 |V        |  3|  3|\n|5√ó3 |V        |  3|  4|\n|5√ó3 |V        |  3|  5|\n\n\n:::\n\n### Storing the Solution in Nested Table\n\nUse nest(.by = c(solution_num, dim)) to store each solution‚Äôs data in a list column. That way, each row in pento_min corresponds to one puzzle solution, containing the relevant (x, y, sol_text) data in a nested data frame.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Store solution in nested way\"}\npento_min <- pento_sol_df |>\n  filter(sol_text != \".\") |>  # exclude the \".\" cells\n  select(x, y, sol_text, solution_num, dim) |>\n  nest(.by = c(solution_num, dim))\n```\n:::\n\n\n\n\n### Creating Graphs with tidygraph & ggraph üìà\n\nTo visualize the connections between pieces, we‚Äôll use tidygraph to create graph objects and ggraph for plotting.\n\n\n\n#### Function: Data Frame to Graph Conversion\n\nThis function converts a solution‚Äôs data frame into a graph by identifying adjacent cells.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Convert Data Frame to igraph Object \"}\ndf_to_graph <- function(data) {\n  \n  # cross join is expensive, but straightforward: \n  # generate all pairs of cells, then filter to pairs that are adjacent (Manhattan distance = 1).\n  tmp <- data |>\n    cross_join(data) |>\n    filter((abs(x.x - x.y) + abs(y.x - y.y)) == 1) |>\n    distinct()\n  \n  edges <- tmp |>\n    transmute(\n      from = paste(x.x, y.x, sol_text.x, sep = \",\"),\n      to   = paste(x.y, y.y, sol_text.y, sep = \",\"),\n      w    = if_else(sol_text.x == sol_text.y, 1, 0.1)\n    )\n  \n  # Standardize from/to to avoid duplicate edges in undirected graph\n  edges_unique <- edges %>%\n    rowwise() %>%\n    mutate(\n      a = min(from, to),\n      b = max(from, to)\n    ) %>%\n    ungroup() %>%\n    distinct(a, b, .keep_all = TRUE) %>%\n    select(-a, -b)\n  \n  graph <- tidygraph::as_tbl_graph(edges_unique, directed = FALSE)\n  \n  # Add node attributes\n  graph <- graph |>\n    mutate(\n      x     = as.numeric(str_split_i(name, \",\", 1)),\n      y     = as.numeric(str_split_i(name, \",\", 2)),\n      piece = str_split_i(name, \",\", 3)\n    ) |>\n    mutate(\n      deg   = centrality_degree(weights = w),\n      btwn  = centrality_betweenness(weights = w),\n      sub_g = centrality_subgraph(),\n      idx   = row_number()\n    )\n  \n  return(graph)\n}\n```\n:::\n\n\n\n#### Function: Graph Visualization\n\nThis function plots the graph using `ggraph` and highlights adjacency within pieces.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Visualizing igraph object with ggraph \"}\nplot_graph <- function(g) {\n  g |>\n    activate(\"nodes\") |>\n    mutate(comm = group_louvain(weights = w)) |>\n    ggraph(layout = \"manual\", x = x, y = y) +\n    \n    # 1) Thicker edges for cells in the same piece\n    geom_edge_link(\n      lineend = \"round\", linejoin = \"mitre\", alpha = 0.8,\n      aes(edge_color = .N()$piece[from], edge_width = I(if_else(w == 1, 7, w)))\n    ) +\n    \n    # 2) Another edge layer (white dash) just as decoration\n    geom_edge_link(\n      lineend = \"square\", linejoin = \"round\", alpha = 0.8,\n      aes(edge_width = I(w)), color = \"#ffffff\", linetype = 3\n    ) +\n    \n    coord_fixed() +\n    theme_nothing() +\n    scale_edge_color_manual(values = retro12) +\n    scale_x_continuous(expand = expansion(add = 1)) +\n    scale_y_reverse(expand = expansion(add = 1))\n  \n}\n```\n:::\n\n\n\n\n### Wrapping It Up with patchwork üñºÔ∏è\n\nFinally, let‚Äôs use patchwork to combine multiple graphs into a single layout.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Utilizing wrap_plot function\"}\nindexes <- c(14369:15378) |> sample(size = 24)\n\nlist_of_plots <- indexes %>%\n  map(~ {\n    pento_min$data[[.x]] %>%\n      df_to_graph() %>%\n      plot_graph()\n  })\n\nwrap_plots(list_of_plots, ncol = 3) +\n  plot_annotation(\n    title = \"Collection of Pentomino Solutions (5x12)\",\n    theme = theme(text = element_text(family = \"Roboto Condensed\"))\n  ) +\n  plot_layout()\n```\n\n::: {.cell-output-display}\n![](pentomino_part4_files/figure-html/unnamed-chunk-8-1.png){width=921.6}\n:::\n:::\n",
    "supporting": [
      "pentomino_part4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}