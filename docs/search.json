[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "🌌 Welcome to the Chi(χ)-Files!\nThis blog follows my data adventures, tech explorations, and creative thinking. 💧\n\n\n🧑‍💻 Who Am I?\nI’m a Data Visualization Specialist whose work spans data science, analytics, and storytelling. I aim to transform raw data into meaningful insights that drive better decision making. I fell in love exploring data using R (with extra special love 💕 for ggplot2), I also love tinkering with SQL, Databricks, as well as utilizing ordinary Microsoft PowerPoints as dynamic storytelling platforms.\n\n\n🫣A Few Fun Facts\n\n🐱 I lean towards more like “cat”—independent, curious, and always exploring, taking pleasure in discoveries.\n🐶 That said, if asked, I’m a dog person. Dogs hold a special place in my heart ❤️, and my furry friend is my constant companion.\n🌊 I’m captivated by waves—from the rolling ocean swells to the invisible rhythms of radio frequencies. I am drawn to patterns especially geometric ones, not simply waves.\n🛸 The name “Chi(χ)-Files” represents my passion for mystery, adventure, and the unknown.\n\n\n\n✍️ Why This Blog?\nThis space showcases my discoveries in data, visualization, and technology. Here you’ll find some professional insights, personal reflections, and likely more of odd creative projects utilizing R in some way. 🎨📊\nThis blog aims to inspire, demonstrating how data can be both functional and beautiful, analytical and artistic. 💡\n\n\n🌊 Join the Journey\nFeel free to explore, share, and connect. Whether you’re a data enthusiast, a curious learner, or seeking inspiration, I hope the Chi-Files resonates with you."
  },
  {
    "objectID": "posts/2024_12/calendar_generator.html",
    "href": "posts/2024_12/calendar_generator.html",
    "title": "Visualizing 445 Calendar in R",
    "section": "",
    "text": "Have You Heard of the 4-4-5 Calendar? 📆\nIf you’ve worked in retail, you might already know that time isn’t always measured in standard months. Enter the 4-4-5 calendar: a reporting tool that divides a year into 12 periods, each organized into quarters of 4, 4, and 5 weeks (i.e. 13 weeks in each quarter). This structure ensures comparability across years by standardizing the length of each reporting period. (But yes, this isn’t perfect either—every 5-6 years, this produces a year with 53 weeks.)\n\n\nWhy Use a 4-4-5 Calendar?\nStandard Gregorian calendars often lead to reporting headaches🤕, especially when months have varying lengths or different counts of weekends. The 4-4-5 calendar solves this by:\n\nAligning periods to weeks, making year-over-year comparisons simpler.\nStandardizing reporting cycles, especially for weekly-driven industries like retail.\nProviding flexibility with alternative formats, such as the 4-5-4 calendar, for specific business needs.\n\nThere’s also a sibling version👧🏻, the 4-5-4 calendar, which I personally prefer because it ensures that American Thanksgiving 🦃🎁 always falls within Period 11. In contrast, the 4-4-5 calendar may place Thanksgiving in Period 11 or 12, depending on the year.\n\n\nBuilding a Custom 4-4-5 Calendar in R\nTo create a reusable tool, I developed the create_calendar function. This function takes a year and a calendar type (“445” or “454”) and returns a detailed tibble with dates, weeks, periods, and quarters. Function takes the year, and returns calendar as data frame.\n\n\nCreate Calendar Function\ncreate_calendar &lt;- function(year, calendar_type = \"445\", col_pal = NULL, ...) {\n  if (is.null(col_pal)) {\n    col_pal &lt;- ggthemes::tableau_color_pal(\"Hue Circle\")(19)[c(1:13)]\n  }\n  \n  cal &lt;- tibble(\n    dt = seq.Date(ymd(paste0(year-1, \"-12-01\")), ymd(paste0(year, \"-12-31\")), by = \"day\")\n  )\n  \n  wpq &lt;- switch(calendar_type,\n                \"445\" = tibble(\n                  wk = 1:53,\n                  p = sort(c(rep(1:12, each = 4), c(3, 6, 9, 12, 12))),\n                  q = sort(c(rep(1:4, each = 13), c(4)))\n                ),\n                \"454\" = tibble(\n                  wk = 1:53,\n                  p = sort(c(rep(1:12, each=4), c(2, 5, 8, 11, 12))),\n                  q = sort(c(rep(1:4, each = 13), c(4)))\n                ),\n                stop(\"Invalid calendar type. Choose '445' or '454'.\")\n  )\n  \n  cal &lt;- cal |&gt;\n    mutate(\n      yr = isoyear(dt),\n      wk = isoweek(dt),\n      wday = wday(dt, label = TRUE,week_start = getOption(\"lubridate.week.start\", 1))\n    ) |&gt;\n    left_join(wpq, by = \"wk\") |&gt;\n    mutate(color_num=wk + p + q) |&gt;\n    mutate(color_wk = colourvalues::color_values(color_num, \n                                                 palette=farver::decode_colour(col_pal))) |&gt;\n    filter(yr==year)\n  \n  return(cal)\n}\n\n\n\n\nMaking the Visual Calendar\nUsing ggplot2, we can create a visual representation of the calendar. The plot organizes weeks within periods and highlights each period in a grid layout.\nI’ve turned this ggplot2 as another function.\n\n\nPlot Calendar Function\nplot_calendar &lt;- function(cal) {\n  cal |&gt;\n    ggplot(aes(x=wday,y=color_num)) +\n    geom_tile(aes(fill=I(color_wk)), color=\"#ffffffde\") +\n    geom_text(aes(label=day(dt),\n                  color=I(if_else(month(dt)==p,\"#ffffff\",\"#e3e3e3\"))),  \n              family=\"Roboto Condensed\") +\n    geom_text(aes(label=str_c(\"W\",wk),color=I(color_wk),x=0),\n              family=\"Roboto Condensed\", \n              data = . %&gt;% count(wk,color_num,color_wk,p,q))+\n    geom_blank(aes(x=-1)) +\n    scale_y_reverse(breaks=NULL) +\n    scale_x_discrete(labels=~str_sub(.,1L,2L)) +\n    facet_wrap(~p,ncol=3, scales=\"free\") +\n    cowplot::theme_minimal_grid(font_family=\"Roboto Condensed\",line_size=0) +\n    labs(x=\"\",y=\"\")\n}\n\n\n\n2025 - 445 🗓️2025 - 454 🗓️2024 - 445 🗓️2024 - 445 🗓️\n\n\n\n\nCode\ncreate_calendar(year=2025, calendar_type=\"445\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreate_calendar(year=2025, calendar_type=\"454\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreate_calendar(year=2024, calendar_type=\"445\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreate_calendar(year=2024, calendar_type=\"454\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\nWhile the 4-4-5 calendar does simplifies retail reporting, timekeeping isn’t always that straightforward. I’ve taken things up a notch and explore how sunlight, time zones, and Daylight Saving Time adds extra complexity.\n\n\nUp the Complication of Timekeeping by a Few Notches\nAt first glance, keeping track of time seems simple 💡—but dig deeper, and it’s anything but. Add time zones, daylight saving time (DST), and patterns of sunlight to the mix, and you’ve just cranked the complexity up to expert mode. 😅\nI don’t think I’ve solved this puzzle perfectly yet, but here’s my attempt using R’s suncalc package to visualize sunlight data alongside our trusty 4-4-5 calendar.\n\n\nSunlight Length Plot Creation\n## install.package if you don't have it installed.  \nlibrary(suncalc)\n\n# Predefined city list with lat/lon & timezones.  \n# To see full listing of available timezones, OlsonNames()\n\n### Creation of cities tibble\ncities &lt;- tibble(\n  city = c(\n    \"Vancouver\", \"Toronto\", \"New York\", \"Chicago\", \"Los Angeles\", \n    \"Tokyo\", \"Paris\", \"London\", \"Munich\",\n    \"Sydney\", \"Mumbai\", \"Cape Town\", \"Moscow\", \"São Paulo\",\n    \"Denpasar\", \"Lima\", \"Dubai\", \"Bangkok\", \"Istanbul\",\n    \"Reykjavik\", \"Tromsø\", \"Buenos Aires\", \"Cairo\", \"Anchorage\"\n  ),\n  country = c(\n    \"Canada\", \"Canada\", \"United States\", \"United States\", \"United States\",\n    \"Japan\", \"France\", \"United Kingdom\", \"Germany\",\n    \"Australia\", \"India\", \"South Africa\", \"Russia\", \"Brazil\",\n    \"Indonesia\", \"Peru\", \"United Arab Emirates\", \"Thailand\", \"Turkey\",\n    \"Iceland\", \"Norway\", \"Argentina\", \"Egypt\", \"United States\"\n  ),\n  lat = c(\n    49.246292, 43.65107, 40.712776, 41.878113, 34.052235, \n    35.689487, 48.856613, 51.507222, 48.135124,\n    -33.868820, 19.076090, -33.924870, 55.755825, -23.550520,\n    -8.650000, -12.046374, 25.276987, 13.756331, 41.008240,\n    64.1466, 69.6496, -34.603722, 30.044420, 61.218056\n  ),\n  lon = c(\n    -123.116226, -79.347015, -74.005974, -87.629799, -118.243683, \n    139.691711, 2.352222, -0.1275, 11.581981,\n    151.209290, 72.877426, 18.424055, 37.617298, -46.633308,\n    115.216667, -77.042793, 55.296249, 100.501762, 28.978359,\n    -21.9426, 18.9560, -58.3816, 31.2357, -149.900278\n  ),\n  tz = c(\n    \"America/Vancouver\", \"America/Toronto\", \"America/New_York\", \"America/Chicago\", \n    \"America/Los_Angeles\", \"Asia/Tokyo\", \"Europe/Paris\", \"Europe/London\", \n    \"Europe/Berlin\", \"Australia/Sydney\", \"Asia/Kolkata\", \"Africa/Johannesburg\", \n    \"Europe/Moscow\", \"America/Sao_Paulo\", \"Asia/Makassar\", \"America/Lima\", \n    \"Asia/Dubai\", \"Asia/Bangkok\", \"Europe/Istanbul\",\n    \"Atlantic/Reykjavik\", \"Europe/Oslo\", \"America/Argentina/Buenos_Aires\", \n    \"Africa/Cairo\", \"America/Anchorage\"\n  )\n)\n\n\n\n# Generalized function \nvisualize_sunlight &lt;- function(city_name, year) {\n  # Find city details\n  #city_name &lt;- (\"Vancouver, BC\")\n  #year &lt;- 2025\n  city &lt;- cities %&gt;% filter(city == city_name)\n  if (nrow(city) == 0) stop(\"City not found in predefined list.\")\n  \n  # Get sunlight data for the year\n  \n  sunlight_data &lt;- create_calendar(year = year) %&gt;%\n    pull(dt) %&gt;%\n    map_dfr(~ getSunlightTimes(date = ., lat = city$lat, lon = city$lon, tz = city$tz)) %&gt;%\n    as_tibble()  %&gt;%\n    mutate(\n      daylight_dur = as.duration(sunrise %--% sunset),\n      across(where(is.POSIXct), \n             list(time = ~ lubridate::hms(format(ymd_hms(.), \"%H:%M:%S\"))))\n    )\n  \n  # Add calendar columns\n  sunlight_data &lt;- sunlight_data %&gt;% bind_cols(create_calendar(year = year))\n  \n  # Summarise by Period\n  p_summary &lt;- sunlight_data |&gt;\n  group_by(p) |&gt;\n  summarise(\n    across(c(dt:color_num), list(min = ~min(.), max = ~max(.))),\n    avg_dur = mean(daylight_dur)\n  ) |&gt;\n  mutate(\n    avg_dur_seconds = as.numeric(avg_dur),  # Convert duration to seconds\n    avg_dur_hours = avg_dur_seconds / 3600,  # Convert seconds to hours\n    descr = str_glue(\n      \"P{p}\\n{format(dt_min, '%Y %b %e')} - {format(dt_max, '%Y %b %e')}\\n\",\n      \"Avg Daylight: {round(avg_dur_hours, 2)} hours\"\n    )\n  ) |&gt;\n  relocate(p, descr)\n  \n  # Detect DST start and end\n  dst_info &lt;- tibble(\n    date = sunlight_data$date,\n    is_dst = with_tz(ymd_hms(paste(date, \"00:00:00\")), tzone = city$tz) %&gt;% dst()\n  ) %&gt;% filter(is_dst) %&gt;%\n    filter(max(date)==date|min(date)==date)\n  \n  # Dynamically create subtitle\n  if (nrow(dst_info) == 0) {\n    subtitle &lt;- \"This location does not observe Daylight Saving Time (DST).\"\n  } else {\n    dst_start &lt;- if_else(city$lat&gt;0,min(dst_info$date),max(dst_info$date))\n    dst_end &lt;- if_else(city$lat&gt;0,max(dst_info$date),min(dst_info$date))\n    subtitle &lt;- str_glue(\"DST Starts: {format(dst_start, '%b %e %a (Week %V)')} | DST Ends: {format(dst_end, '%b %e %a (Week %V)')}\")\n  }\n  \n  # Generate the plot\n  ggplot(sunlight_data, aes(x = as.numeric(color_num) + as.numeric(wday) / 7)) +\n    geom_ribbon(aes(ymin = dawn_time, ymax = dusk_time, fill = I(colorspace::lighten(color_wk, 0.7)))) +\n    geom_ribbon(aes(ymin = sunrise_time, ymax = sunset_time, fill = I(color_wk))) +\n    geom_line(aes(y = solarNoon_time), linetype = 3) +\n    scale_x_continuous(breaks = NULL) +\n    cowplot::theme_minimal_vgrid(font_family = \"Roboto Condensed\") +\n    geom_hline(yintercept = max(as.numeric(sunlight_data$sunrise_time)), color = \"black\", linetype = 3) +\n    geom_hline(yintercept = min(as.numeric(sunlight_data$sunrise_time)), color = \"black\", linetype = 3) +\n    geom_hline(yintercept = max(as.numeric(sunlight_data$sunset_time)), color = \"black\", linetype = 3) +\n    geom_hline(yintercept = min(as.numeric(sunlight_data$sunset_time)), color = \"black\", linetype = 3) +\n    scale_y_continuous(\n      labels = ~ hms::as_hms(.),\n      breaks = seq(0, 24 * 3600, by = 3600), # Hourly breaks\n      limits = c(0, 24 * 3600)\n    ) +\n    labs(\n      x = \"\",\n      y = \"\",\n      title = str_glue(\"Sunlight Duration for {city_name} {city$country} ({year}) - 445 Calendar\"),\n      subtitle = subtitle\n    ) +\n    geom_label(aes(x=color_num_min, \n                  y=avg_dur_seconds, label=str_c(\"P\",p,\"\\navg\\n\", round(avg_dur_hours,1),\"\\nhrs\")),\n              data = p_summary, family=\"Roboto Condensed\", \n              lineheight=0.8, hjust=0, fill=\"#ffffff50\")\n}\n\n\n\nVancouver 🇨🇦New York 🇺🇸Munich 🇩🇪Tromsø 🇳🇴Sydney 🇦🇺Tokyo 🇯🇵Denpasar 🇮🇩Cairo 🇪🇬\n\n\nVancouver 🇨🇦🌲⛰️ Daylight Saving Time: DST is observed from March to November. Summer days are long (about 16 hours) while winter days are short (about 8 hours). 👩🏻‍🏫 There are more than twice as many daylight hours on the summer solstice than on the winter one.\n\n\nCode\nvisualize_sunlight(\"Vancouver\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nNew York 🇺🇸🗽🏙 Daylight Saving Time: DST is observed from March to November, just like Vancouver. About 15 hours in the summer and about 9.4 hours in the winter, New York’s patterns are slightly less pronounced than Vancouver’s but still notable.\n\n\nCode\nvisualize_sunlight(\"New York\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nMunich 🇩🇪🍺🏰 Daylight Saving Time: Commences in late March and concludes in late October. Sunlight: Summer days last approximately 16 hours, while winter days last approximately 8.5 hours.\n\n\nCode\nvisualize_sunlight(\"Munich\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nTromsø 🇳🇴❄️🌌 **Tromsø’s graph below is broken due to the sun setting after midnight during the summer (a phenomenon called the midnight sun), and I didn’t think through on these edge cases while creating ggplot2!\nDaylight Saving: Starts last Sunday in March, ends last Sunday in October in Norway. That said, Tromsø (and other places in the Arctic Circle) experience midnight sun and polar night - So DST has no actual practical effect??!\n\n\nCode\nvisualize_sunlight(\"Tromsø\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nSydney 🇦🇺🌊🐨 Daylight Saving: Starts first Sunday in October, ends first Sunday in April as seen on the glitch on visual below. I didn’t quite get the extraction of DST accurately in my function, so subtitle still isn’t accurate… 😅 🙀Another interesting thing I learned is that Not all states observe DST in Australia 🇦🇺! This creates a patchwork of timezones during the summer in Australia!\n\n\nCode\nvisualize_sunlight(\"Sydney\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nTokyo 🇯🇵🏙️🌸 Daylight Saving: Japan doesn’t observe DST (Since 1952). Most of Japan experiences consistent sunrise and sunset times throughout the year, making DST less beneficial.\n\n\nCode\nvisualize_sunlight(\"Tokyo\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nDenpasar 🇮🇩🌴🌊 Like the rest of Indonesia, Bali does not observe DST. The daylight time remains constant throughout the year due to its tropical, equatorial location thoughout the year. So there’s really no need for DST.\n\n\nCode\nvisualize_sunlight(\"Denpasar\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nCairo 🇪🇬🕌🐪 Daylight Saving: Unlike Canada or US, DST transition occurs on Friday in Late April and Thursdays in Late October, instead of more typical Sunday.\n\n\nCode\nvisualize_sunlight(\"Cairo\", 2025)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhere are these cities?\nHere’s a map of the cities I’ve picked in above.\n\n\nInteractive Leaflet Map Code\nlibrary(leaflet)\n\ncities |&gt; \n  filter(city %in% c(\"Tokyo\",\"Denpasar\",\"Vancouver\",\"New York\",\"Munich\",\"Sydney\",\"Cairo\",\"Tromsø\")) |&gt;\n  leaflet() |&gt;\n  addProviderTiles(\"CartoDB.DarkMatter\") |&gt;\n  addMarkers(\n    label = ~city,\n    popup = ~map(paste0(\n    \"&lt;b&gt;\", city, \", \",country, \"&lt;/b&gt;&lt;br&gt;\",\n    \"Lat: \", round(lat, 2), \"&lt;br&gt;\",\n    \"Lon: \", round(lon, 2)\n  ), htmltools::HTML\n  ),\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"bold\", \"color\" = \"white\"),\n      direction = \"auto\",\n      textsize = \"12px\",\n      noHide = TRUE,\n      textOnly = TRUE,\n      sticky = TRUE\n    )\n  )\n\n\n\n\n\n\n\n\nTimekeeping: A Rabbit Hole Worth Falling Into 🐰🕳️\nWhat started as a simple exploration of the 4-4-5 calendar turned into a wild ride through the quirks of time—daylight saving oddities, cultural twists, and even the midnight sun.\nI love these “useless trivias,” but they’re a reminder that time isn’t just ticking numbers on a clock—it’s shaped by geography, culture, and sometimes even political drama. This was a fun wake-up call (pun intended) that time is more complex, and entertaining? than we think!!"
  },
  {
    "objectID": "posts/2024_12/index.html",
    "href": "posts/2024_12/index.html",
    "title": "Fish-Eye Lens Effect with ggplot2",
    "section": "",
    "text": "Fascination with “Warping” …\nThe “fish-eye” lens has always fascinated me. It was my gateway into photography—its quirky, distorted charm never failed to add whimsy to my shots. Some of my favourite memories are capturing our furry friends🐶🐽🐄.\nRecently, I started wondering why not bring that same fish-eye🐟👁️ magic into my data visualizations. While it may not suit business dashboards, it’s perfect for artistic visualizations. With ggplot2’s coord_trans() and its \"pseudo_log\" transformation as inspiration, I decied to push the boundaries and create my first custom transformation.\n\n\nDigression : The Seigaha Motif as a Canvas 🎨\nTo test this idea, I used a Seigaha motif I created the other day. It’s a geometric design with overlapping circles that naturally lends itself to experimentation. I introduced randomness to the colors using irrational numbers as denominators, leveraging R’s modulo operation for real numbers. Just another attempt at creating “pseudo-randomness” in the design.\n\\[\nx \\mod y = x - \\text{floor}\\left(\\frac{x}{y}\\right) \\times y\n\\]\n\nFamous “Irrational” Numbers in Math\n\nGolden Ratio\nThe Golden Ratio is often represented by the Greek letter \\(\\phi\\) and is defined as: \\[\n\\phi = \\frac{1 + \\sqrt{5}}{2}\n\\]\n\n\nSilver Ratio\nThe lesser-known Silver Ratio, represented by \\(\\delta_s\\), is defined as: \\[\n\\delta_s = 1 + \\sqrt{2}\n\\]\n\n\nEuler’s Number\nEuler’s number, represented by \\(e\\), is a fundamental constant in mathematics: \\[\ne = \\exp(1)\n\\] It is approximately \\(e \\approx 2.718\\).\n\n\nCode\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse' \nlibrary(ggforce) # Accelerating 'ggplot2'   \nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'  \nlibrary(gt) # Easily Create Presentation-Ready Display Tables \n\n### just declaring the colour palette here\ncol10 &lt;- str_split(\"001219-005f73-0a9396-94d2bd-e9d8a6-ee9b00-ca6702-bb3e03-ae2012-9b2226\",\"-\")\ncol10_pal &lt;-str_c(\"#\",col10 |&gt; unlist())\n\n### Creating data frame that is basis of layout\ndf &lt;- expand_grid(x = seq(-12, 12, by = 2), \n                  y = seq(-8, 8, by = 1)) |&gt;\n  arrange(y,x) |&gt;\n  mutate(y_odd=(y%%2==1)) |&gt;\n  mutate(idx=row_number()-1) |&gt;\n  mutate(x=if_else(y_odd,x+1,x))\n\n### For each grid location, I want 6 concentric circles\nr_values &lt;- seq(0.1,1,length.out=6)\n\n### Just defining some \"Irregular Numbers\" that I can use with Modulo \ngr &lt;- (1 + sqrt(5)) / 2 ## the golden ratio \nsr &lt;- (1 + sqrt(2)) ##. lesser known silver ratio\neuler_num &lt;- exp(1)\n\ndf_long &lt;- df |&gt; expand_grid(r=r_values) |&gt;\n  mutate(r_var=r*(idx%%sr)+1) ## I'm experimenting here with modulo with pi \n\n\n\n\n\n\nCartesian Coordinates: The Baseline\nHere’s the unaltered design using coord_fixed, maintaining regular Cartesian coordinates.\n\n\nCode\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  #coord_trans(x=\"pseudo_log\",y=\"pseudo_log\",clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nEntering the World of Distortion\n\nPseudo-Log Transformation\nWarping begins with using pseudo_log transformation with coord_trans creates an intriguing distortion:\n\n\nCode\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  coord_trans(x=\"pseudo_log\",y=\"pseudo_log\",clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nCustom Fisheye Transformation\nInspired by radial distortion formula, I’ve attempt to write a custom fisheye transformation.\nk controls the intensity of the distortion.\n\nPositive k = Barrel Distortion (like Fisheye)\nNegative k = Pincusion Distortion (Inverse Fisheye).\nr’ is pronouced as “r prime” \\[\nr′=r⋅(1+k*r^2)\n\\] Here’s the implementation:\n\n\n\nCode\nlibrary(scales)\n\n# Define a fisheye transformation using trans_new\nfisheye_trans &lt;- function(k = 0.01) {\n  trans_new(\n    name = \"fisheye\",\n    transform = function(r) r * (1 + k * r^2),        # Forward transformation\n    inverse = function(r_prime) r_prime / (1 + k * r_prime^2)  # Inverse transformation\n  )\n}\n\n# Create the fisheye transformation object\nfisheye &lt;- fisheye_trans(k = 0.03)\n\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  #coord_trans(x=\"pseudo_log\",y=\"pseudo_log\",clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  coord_trans(x=fisheye, y=fisheye) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\nThe result didn’t quite meet my expectations.. 😅🥹, but it’s a start…!\n\n\n\nExperimenting with Modulus Transformation in scales package 📦\nI also explored transformations like modulus, which yielded effects closer to the fish-eye look I envisioned:\n\n\nCode\n# Define the modulus transformation with a specific parameter (e.g., p = 0.5)\nmod_trans_y &lt;- modulus_trans(p = 0.01)\n\n\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  coord_trans(x=mod_trans_y ,y=mod_trans_y ,clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nCode\nmod_trans_x &lt;- modulus_trans(p = 1.5)\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  coord_trans(x=mod_trans_x ,y=mod_trans_y ,clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nFinal Thoughts\nExperimenting with warping in ggplot2 opens up a playful avenue for some quirky visualizations. I’m now thinking what to distort next!"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Hello World! The First Post!",
    "section": "",
    "text": "Every great journey begins with a single step—or in this case, a single post. Really I’m just trying to learn how to use Quarto…\n\n\nThe blog name is a nod to my love of mystery, discovery, and exploration. Data can be like an unsolved case—full of patterns, stories, and hidden gems waiting to be uncovered.\n\n\n\nX-Files\n\n\n\n\n\nIn the Chi-Files, every dataset is a puzzle, and the chi-square statistic is our investigative tool to uncover hidden relationships.\nThe formula for the chi-square statistic is:\n\\[\n\\chi^2 = \\sum \\frac{(O_i - E_i)^2}{E_i}\n\\]\nWhere: - \\(O_i\\) = Observed frequency - \\(E_i\\) = Expected frequency - \\(\\sum\\) = The summation symbol, meaning we sum across all categories.\n\n\n\nSuppose we’re investigating sightings of UFOs 👽 across regions:\n\n\n\n\n\n\n\n\nRegion\nObserved Sightings (\\(O_i\\))\nExpected Sightings (\\(E_i\\))\n\n\n\n\nArea 51\n50\n40\n\n\nRoswell\n70\n60\n\n\nPine Gap\n30\n50\n\n\n\nUsing the chi-square formula, we calculate:\n\\[\n\\chi^2 = \\frac{(50 - 40)^2}{40} + \\frac{(70 - 60)^2}{60} + \\frac{(30 - 50)^2}{50}\n\\]\nThis leads to:\n\\[\n\\chi^2 = \\frac{100}{40} + \\frac{100}{60} + \\frac{400}{50} = 2.5 + 1.67 + 8 = 12.17\n\\]\nIf this value exceeds the critical value, we may conclude there’s something strange going on in these regions… but the truth is out there! 🛸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe chi-square test reveals mysteries hidden in plain data. Use it wisely, and remember: the truth is out there! 🛸\n\n\nVisit Quarto"
  },
  {
    "objectID": "posts/welcome/index.html#welcome-to-the-chi-files",
    "href": "posts/welcome/index.html#welcome-to-the-chi-files",
    "title": "Hello World! The First Post!",
    "section": "",
    "text": "Every great journey begins with a single step—or in this case, a single post. Really I’m just trying to learn how to use Quarto…\n\n\nThe blog name is a nod to my love of mystery, discovery, and exploration. Data can be like an unsolved case—full of patterns, stories, and hidden gems waiting to be uncovered.\n\n\n\nX-Files\n\n\n\n\n\nIn the Chi-Files, every dataset is a puzzle, and the chi-square statistic is our investigative tool to uncover hidden relationships.\nThe formula for the chi-square statistic is:\n\\[\n\\chi^2 = \\sum \\frac{(O_i - E_i)^2}{E_i}\n\\]\nWhere: - \\(O_i\\) = Observed frequency - \\(E_i\\) = Expected frequency - \\(\\sum\\) = The summation symbol, meaning we sum across all categories.\n\n\n\nSuppose we’re investigating sightings of UFOs 👽 across regions:\n\n\n\n\n\n\n\n\nRegion\nObserved Sightings (\\(O_i\\))\nExpected Sightings (\\(E_i\\))\n\n\n\n\nArea 51\n50\n40\n\n\nRoswell\n70\n60\n\n\nPine Gap\n30\n50\n\n\n\nUsing the chi-square formula, we calculate:\n\\[\n\\chi^2 = \\frac{(50 - 40)^2}{40} + \\frac{(70 - 60)^2}{60} + \\frac{(30 - 50)^2}{50}\n\\]\nThis leads to:\n\\[\n\\chi^2 = \\frac{100}{40} + \\frac{100}{60} + \\frac{400}{50} = 2.5 + 1.67 + 8 = 12.17\n\\]\nIf this value exceeds the critical value, we may conclude there’s something strange going on in these regions… but the truth is out there! 🛸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe chi-square test reveals mysteries hidden in plain data. Use it wisely, and remember: the truth is out there! 🛸\n\n\nVisit Quarto"
  },
  {
    "objectID": "posts/pentomino/pentomino_part3.html",
    "href": "posts/pentomino/pentomino_part3.html",
    "title": "Compact Pentomino Solution : Parquet Magic",
    "section": "",
    "text": "Saving the sf Object (Pentomino Solutions) for Later Use as Parquet 📦\nConfession time: I only discovered Parquet files last year. 🙈 For someone who spends a good chunk of their time in the data world, it felt like a secret club I wasn’t part of. But hey, if you’re not in that club yet either, let’s join together now! 🎉\nLast few days, I was working with an sf object containing solutions for my Pentomino puzzles. (Original Solution is from this amazing Pentomino Website by Isomer Design). Now, Pentomino solution isn’t “big data” by any stretch (I usually deal with much larger datasets in my business work). But even so, the file was big enough that I couldn’t just upload it to GitHub.😅\nThis got me thinking: what if I save the sf object as Parquet format to reduce the file size, and so I can reuse the file later on.\n\n\nWhy Parquet\nThink of Parquet as the ultra-organized sibling to CSV. While CSV is great for simplicity, Parquet packs your data more tightly and efficiently—like Marie Kondo personally folding each column! ✨\nIn terms of size, my Pentomino solutions went from a hefty 105MB GeoJSON to a feather-light 695KB Parquet file. Perfect for GitHub! 🔥 (P.S. You’ll see this dataset in action shortly!)\nIt’s not just about saving space—though. It’s also about speed 🏎️. Parquet makes it faster to read, write, and process data, which become crusial when working with millions of rows of data.\n\n\nConverting & Writing sf file to Parquet\n# Load required libraries\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse' \nlibrary(sf) # Simple Features for R        \nlibrary(arrow) # Integration to 'Apache' 'Arrow'    \n\n# Save Pentomino solutions in different formats\npento_sf |&gt; write_rds(file = \"data/pentomino_solution_sf.rds\")  # RDS format\n# To reload later: pento_sf &lt;- read_rds(\"data/pentomino_solution_sf.rds\")\n\npento_sf |&gt; write_sf(\"data/pentomino_solution_sf.geojson\")  # GeoJSON format\n\n# Attempting to save as Parquet using write_sf (this doesn't work)\npento_sf |&gt; write_sf(\"data/pentomino_solution_sf.parquet\")\n# Error: write_sf can't write Parquet files directly! \n\n# Alternative: Using write_parquet (this also fails for spatial objects)\npento_sf |&gt; write_parquet(\"data/pentomino_solution_sf.parquet\")\n# Error: Can't infer Arrow data type from object inheriting from XY / POLYGON / sfg.\n\n# Convert sf object to data frame because write_parquet with geometry fails.\npento_df &lt;- pento_sf %&gt;% \n  mutate(wkt = st_as_text(geometry)) |&gt; # Convert geometry to WKT format\n  st_drop_geometry() ## now I've converted geometry column, I don't need them\n\npento_df |&gt; write_parquet(\"data/pentomino_solution_sf.parquet\")\n##https://arrow.apache.org/docs/r/reference/write_parquet.html\n\n# File size comparison (approximate):\n# data/pentomino_solution_sf.geojson   105.51 MB\n# data/pentomino_solution_sf.rds       110.62 MB\n# data/pentomino_solution_sf.parquet   695 KB (so small!!)\n\n\nFor larger or more complex datasets, you might not see this dramatic size reduction, but Parquet still offers significant savings and speed! Because this pentomino sf dataset is actually quite simple. File size reduction is quite impressive!\nI’ve uploaded this parquet file to Github repo. So I’ll read in the solution file from Github in below.\n\n\nReading in Pentomino Solution Parquet File from GitHub\n# Load required libraries\nlibrary(tidyverse) # Data manipulation and visualization\nlibrary(arrow)     # Integration with Apache Arrow for Parquet files\nlibrary(sf)        # Simple Features for handling spatial data\nlibrary(cowplot)   # Streamlined ggplot2 themes and annotations\n\n# Just Prepping some color palette\nretro &lt;-  c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\nretro12 &lt;- colorRampPalette(retro)(12)\npiece&lt;-c(\"F\",\"I\",\"L\",\"N\",\"P\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")\nnames(retro12) &lt;- piece\n\n# Read Parquet file from GitHub\npento_df &lt;- read_parquet(\"https://github.com/chichacha/pentomino/raw/refs/heads/main/pentomino_solution_sf.parquet\")\n\n# Convert WKT column back to geometry to recreate the spatial object\npento_sf &lt;- pento_df |&gt; \n  st_as_sf(wkt = \"wkt\") |&gt;        # Convert WKT strings into spatial geometries\n  rename(geometry = wkt)          # Rename for compatibility with sf conventions\n\n# Show the structure of pento_sf\nglimpse(pento_sf) \n\n\nRows: 321,416\nColumns: 5\n$ sol_idx   &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ dim       &lt;chr&gt; \"3×10\", \"3×10\", \"3×10\", \"3×10\", \"3×10\", \"3×10\", \"3×15\", \"3×1…\n$ value     &lt;chr&gt; \"F\", \"I\", \"N\", \"P\", \"U\", \"Y\", \"F\", \"I\", \"L\", \"N\", \"P\", \"T\", …\n$ piece_cnt &lt;int&gt; 6, 6, 6, 6, 6, 6, 9, 9, 9, 9, 9, 9, 9, 9, 9, 12, 12, 12, 12,…\n$ geometry  &lt;POLYGON&gt; POLYGON ((6.5 0.5, 5.5 0.5,..., POLYGON ((0.5 1.5, 1.5 1…\n\n\n\n\nSolution Counts per Puzzle Dimension\nHave you ever wondered how different puzzle dimensions influence the number of possible solutions? In below plot, the length of the bar reflects the abundance of solutions per pieces being used.\nThis visualization is based on solutions provided by isomerdesign.com, a fantastic resource for pentomino enthusiasts. After parsing their solution files, I discovered a total of 33,008 solutions spanning 46 unique puzzle dimensions. 46 Dimensions - 3×10, 3×15, 3×20, 3×21a, 3×21b, 3×21c, 3×21d, 4×10, 4×15, 4×16a, 4×16b, 4×16c, 4×16d, 4×16e, 4×16g, 4×16h, 4×16i, 4×16k, 5×10, 5×11, 5×12, 5×3, 5×4, 5×5, 5×6, 5×7, 5×8, 5×9, 6×10, 8×8a, 8×8b, 8×8c, 8×8d, 8×8e, Triplicate F, Triplicate I, Triplicate L, Triplicate N, Triplicate P, Triplicate T, Triplicate U, Triplicate V, Triplicate W, Triplicate X, Triplicate Y, Triplicate Z\n\n\nCreation of Stacking Bar Chart with ggplot2\npento_sf |&gt;\n  st_drop_geometry() |&gt;   #By dropping geometry, computation is quicker\n  group_by(dim,piece_cnt) |&gt;\n  summarise(solution_cnt=max(sol_idx),.groups = \"drop\") |&gt; \n  #filter(piece_cnt==3)\n  #count(dim,wt=solution_cnt,sort=T) |&gt; arrange(n)\n  ggplot(aes(x=fct_reorder(as.factor(piece_cnt),solution_cnt,sum,.desc=F),\n             y=solution_cnt)) +\n  geom_col(aes(fill=dim, group=dim)) +\n  ggfittext::geom_fit_text(aes(label=str_c(dim,\"\\n\",scales::comma(solution_cnt)), group=dim),position=\"stack\", family=\"Roboto Condensed\") +\n  coord_flip() +\n  scale_fill_manual(values=colorRampPalette(retro)(length(unique(pento_sf$dim))), guide=\"none\") +\n  labs(\n  title = \"Number of Solutions Provided per Pieces Used\",\n  subtitle = \"Based on solution files from isomerdesign.com\",\n  caption = \"Data Source: https://isomerdesign.com/Pentomino/\",\n  y = \"Number of Solutions\", x=\"Number of Pentomino Pieces Used in Puzzle\") +\n  theme_minimal_vgrid(font_family=\"Roboto Condensed\") +\n  annotate(geom=\"text\",x=\"9\",y=0,label=\"*Triplicate Series*\\n\", hjust=0, vjust=0,\n           family=\"Roboto Condensed\", size=3,fontface = \"italic\") +\n  annotate(geom=\"label\",x=\"5\", y=120, label=\"&lt;&lt;&lt; 5x5 squares can be made 107 different ways!\", hjust=0, family=\"Roboto Condensed\", size=3, fill=\"lightyellow\") +\n  annotate(geom=\"label\",x=\"4\", y=100, label=\"&lt;&lt;&lt; 5x4 rectangles can be made 50 different ways\", hjust=0, family=\"Roboto Condensed\", size=3, fill=\"lightyellow\") +\n  annotate(geom=\"label\",x=\"3\", y=50, label=\"&lt;&lt;&lt; 5x3 rectangles can be made 7 different ways\", hjust=0, family=\"Roboto Condensed\", size=3, fill=\"lightyellow\") +\n  geom_blank(aes(x=\"\"))\n\n\n\n\n\n\n\n\n\n\n\n5x5 Squares: The Ultimate Pentomino Challenge\nHow many ways could you fit a 5x5 square using only five pentomino pieces? Believe it or not, there are 107 unique solutions! 🧩\nSome pieces, like the trusty L, are frequent problem-solvers—they appear in many solutions. Meanwhile, the poor X is the wallflower of this puzzle, only making it into two solutions. It seems that some shapes just get along better with tight grids than others.\nBelow, you’ll find a visualization of all 107 solutions. Each group represents a different combination of pieces, showing which sets of pentominoes team up to conquer the 5x5 challenge. It’s a fascinating glimpse into which pieces are the MVPs and which are sitting out this game.\n\n\n107 5x5 Solutions\npiece_comb &lt;-pento_sf |&gt;\n  filter(piece_cnt==5) |&gt; \n  st_drop_geometry() |&gt;\n  group_by(sol_idx) |&gt;\n  summarise(piece_combo=paste(sort(value),collapse=\"\"),.groups=\"drop\") |&gt;\n  add_count(piece_combo,sort=T)\n\npento_sf |&gt;\n  filter(piece_cnt==5) |&gt; \n  left_join(piece_comb) |&gt;\n  mutate(piece_combo=fct_reorder(piece_combo,n,max,.desc=T)) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=value), color=\"#fffff3\") +\n  scale_fill_manual(values=retro12) +\n  facet_wrap(~piece_combo+sol_idx,ncol=15) +\n  theme_nothing()\n\n\n\n\n\n\n\n\n\nTo dig a little deeper, I also explored how often each piece shows up across the 107 solutions. Below, you can see a breakdown of where each pentomino appears and how many times it’s been part of a winning combination. The number on each piece reflects its frequency—L is clearly the hero of this puzzle appearing in 85 solutions out of 107 (79%), while X is struggling to make an impression.\n\n\nFrequency of Piece Usage & Coverage\npento_sf |&gt;\n  filter(piece_cnt==5) |&gt; \n  group_by(value) |&gt;\n  summarise(freq=n()) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=value), color=\"#fffff3\") +\n  geom_text(aes(label=str_c(value,\" \",freq), x=0.5,y=6.5), \n               family=\"Roboto Condensed\", size=7,\n               fontface=\"bold\", hjust=0, vjust=1) +\n  scale_fill_manual(values=retro12) +\n  facet_wrap(~fct_reorder(value,freq,sum,.desc=T),ncol=6) +\n  theme_nothing()\n\n\n\n\n\n\n\n\n\n\n\nThe Triplicate Series: Pentominoes in 3x Size!\nThere are solutions labeled as Triplicate Series — it’s like a puzzle within a puzzle,Pentomino-ception! 🤯\nNormally, each pentomino consists of 5 squares, but in this series, we take it to the next level. Each pentomino is rebuilt to be 3x bigger using a combination of 9 other pentominoes (excluding itself, of course). The result? A supersized version made up of 45 squares!\nFor example, the classic “L” pentomino is recreated as a massive “L,” but only with help from the rest of the gang (except for the original “L” itself)\n\n\nTriplicated Pentomino\n### Handy helper function to flip the geometry\nflip &lt;- function(direction = \"h\") {\n  if (direction == \"h\") {\n    matrix(c(-1, 0, 0, 1), 2, 2)  # Flip horizontally\n  } else if (direction == \"v\") {\n    matrix(c(1, 0, 0, -1), 2, 2)  # Flip vertically\n  } else {\n    stop(\"Invalid direction. Use 'h' or 'v'.\")\n  }\n}\n\n### Offset so that letters don't overlap\noffset &lt;- function(i,n=6){\n  x &lt;- (i-1)%%n\n  y &lt;- floor((i-1)/n)\n  c(x,y)\n}\n\npento_sf |&gt;\n  filter(str_detect(dim,\"Tri\")) |&gt;\n  filter(sol_idx==1) |&gt;\n  mutate(dim_idx=dense_rank(dim)) |&gt;\n  mutate(offset=map(dim_idx,offset)) |&gt;\n  rowwise() |&gt;\n  mutate(geometry=geometry+offset*13) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=value, geometry=geometry*flip(\"v\")),color=\"#fffff3\") +\n  scale_fill_manual(values=retro12) +\n  theme_nothing()\n\n\n\n\n\n\n\n\n\n\n\nTriplicated Pentomino Example 2\npento_sf |&gt;\n  filter(str_detect(dim,\"Tri\")) |&gt;\n  filter(sol_idx==15) |&gt;\n  mutate(dim_idx=dense_rank(dim)) |&gt;\n  mutate(offset=map(dim_idx,offset)) |&gt;\n  rowwise() |&gt;\n  mutate(geometry=geometry+offset*12.5) |&gt;\n  mutate(geometry=st_buffer(geometry,dist=-0.1)) |&gt;\n  ungroup() |&gt;\n  ggplot() +\n  geom_sf(aes(fill=value, geometry=geometry*flip(\"v\"))) +\n  geom_sf(aes(fill=value, \n              geometry=st_voronoi(geometry*flip(\"v\"),bOnlyEdges = T)),\n          color=\"#fffff350\",linewidth=0.1) +\n  \n  scale_fill_manual(values=retro12) +\n  theme_nothing()\n\n\n\n\n\n\n\n\n\n\n\nWarp for Now…\nAnd with that, the Triplicate Series and 5x5 solutions are just the tip of the Pentomino iceberg. Thank you for going into the rabbit hole with me! 🐇🕳️"
  },
  {
    "objectID": "posts/pentomino/pentomino_part5.html",
    "href": "posts/pentomino/pentomino_part5.html",
    "title": "Utiling geom_arc_bar for creation of geometric art",
    "section": "",
    "text": "Geometry x Colors Experimentation\nI’m still obsessing with Pentomino dataset that I have been using.\nI love using the ggforce package for creating stunning visualizations. ggforce essentially allows you to extend the ggplot2 capabilities, i.e. ggplot2 on steroid. My go-to functions usually include geom_regon, geom_parallel_sets, and geom_circle. But recently, I realized there’s functions I haven’t fully explored, one of them being geom_arc_bar.\n\n\nSetups and Pakcages Used in This Blog Post\n# Load required libraries\nlibrary(tidyverse)    # Data wrangling and general utilities\nlibrary(ggforce)      # Extra geoms for ggplot2 \nlibrary(cowplot)      # Additional plotting helpers\nlibrary(patchwork)    # Combine multiple ggplots effortlessly!\n\n# Pentomino Solutions Dataset \npento_sol &lt;- read_csv(\"https://raw.githubusercontent.com/chichacha/pentomino/refs/heads/main/pentomino_solution.csv\")\n\n### Convert Solution to XY position data frame\npento_sol_df &lt;- pento_sol |&gt;\n  mutate(solution_num = row_number()) |&gt;\n  mutate(sol_text = str_split(sol_text, \" \")) |&gt;\n  unnest(sol_text) |&gt;\n  group_by(solution_num) |&gt;\n  mutate(y = row_number()) |&gt;\n  ungroup() |&gt;\n  mutate(sol_text = str_split(sol_text, \"\")) |&gt;\n  unnest(sol_text) |&gt;\n  group_by(solution_num, y) |&gt;\n  mutate(x = row_number()) |&gt;\n  ungroup()\n\npento_min &lt;- pento_sol_df |&gt;\n  filter(sol_text != \".\") |&gt;  # exclude the \".\" cells\n  select(x, y, sol_text, solution_num, dim) |&gt;\n  nest(.by = c(solution_num, dim))\n\n# Just using my retro color palette\nretro &lt;-  c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\nretro12 &lt;- colorRampPalette(retro)(12)\npiece&lt;-c(\"F\",\"I\",\"L\",\"N\",\"P\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")\nnames(retro12) &lt;- piece\n\n\n\n\nQuick Demo of Basic Use geom_arc_bar function\nHere’s a demo showing the effects of different geom_arc_bar parameters like segment smoothness (n), expansion or contraction (expand), and rounding of corner (radius). I like that I can draw pie or donut chart without leaving cartesian coordinate.\n\n\nSimple Example\n# Sample data\ndata &lt;- data.frame(\n  x = c(0,0,0,0,0,0),\n  y = c(0,0,0,0,0,0),\n  r0=c(rep(0.5,times=4),0,0),\n  r=c(rep(1,times=4),0.5,0.5),\n  start = c(0, pi/2, pi, 3*pi/2,0,pi),\n  end = c(pi/2, pi, 3*pi/2, 2*pi,pi,2*pi),\n  group=c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\")\n)\n\n# Plot using geom_arc_bar\nggplot(data) +\n  geom_arc_bar(aes(\n    x0 = x, y0 = y, r0 = r0, r = r, \n    start = start, end = end, \n    fill = group\n  ), color=\"#fffff3\") +\n  geom_arc_bar(aes(\n    x0 = x+2, y0 = y, r0 = r0, r = r, \n    start = start, end = end, \n    fill = group\n  ), color=\"#fffff3\", n=4) + ## n to control the number of points used to draw a full circle.\n  geom_arc_bar(aes(\n    x0 = x+4, y0 = y, r0 = r0, r = r, \n    start = start, end = end, \n    fill = group\n  ), color=\"#fffff3\", expand=unit(-1,\"mm\")) + ## expand to control expansion, negative value is used to contract\n  geom_arc_bar(aes(\n    x0 = x+6, y0 = y, r0 = r0, r = r, \n    start = start, end = end, \n    fill = group\n  ), color=\"#fffff3\", radius=unit(3,\"mm\"), n=36) +\n  theme_minimal_grid(font_family=\"Roboto Condensed\") +\n  labs(title = \"Fun with geom_arc_bar\", fill = \"Group\") +\n  coord_fixed() +\n  scale_fill_manual(values=c(retro,\"#323433\")) +\n  scale_x_continuous(breaks=c(0,2,4,6)) +\n  scale_y_continuous(breaks=c(-1,0,1))\n\n\n\n\n\n\n\n\n\n\n\nSlightly Abstract Pentomino Solutions\nWhat happens when a classic Pentomino puzzle collides with geometric abstraction? These visuals are still valid solutions to the Pentomino problem, but now they blur the line between puzzles and art. By experimenting with shapes, colors, these solutions have transformed into something entirely new: playful geometric art with a hint of order and chaos 🪄🐰🎩\n\n\nCode\nabstract_plot &lt;- function(i){\n  pento_min$data[[i]] |&gt;\n    arrange(sol_text) |&gt;\n    group_by(sol_text) |&gt;\n    mutate(idx=row_number(),\n           diff_x=x-lag(x,default=1),\n           diff_y=y-lag(y,default=1)) |&gt;\n    ungroup() |&gt;\n    ggplot() +\n    geom_tile(aes(x=x,y=y), fill=\"#fffff3\") +\n    geom_arc_bar(aes(x0=x+0.5,y0=y+0.5,r0=0, r=sqrt(1), start=3*pi/2, end=pi, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx==1)) +\n    geom_arc_bar(aes(x0=x-0.5,y0=y-0.5,r0=0, r=sqrt(1), start=0, end=pi/2, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx==2)) +\n    geom_arc_bar(aes(x0=x+0.5,y0=y-0.5,r0=0, r=sqrt(1), start=0, end=-pi/2, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx==3)) +\n    geom_circle(aes(x0=x,y0=y, r=sqrt(0.25),\n                    fill=sol_text), \n                data = . %&gt;% filter(idx==5),\n                color=\"transparent\") +\n    geom_arc_bar(aes(x0=x+0.5,y0=y+0.5,r0=0, r=sqrt(1), start=3*pi/2, end=pi, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx==4)) +\n    coord_fixed() +\n    scale_fill_manual(values=retro12) +\n    #scale_color_manual(values=retro12) +\n    theme_nothing()\n  \n}\n\npento_min |&gt; filter(dim==\"8×8a\") |&gt; \n  pull(solution_num) |&gt;\n  sample(size=6) |&gt;\n  map(abstract_plot) |&gt;\n  wrap_plots() \n\n\n\n\n\n\n\n\n\n\n\nCode\nlibrary(TSP)\n\nabstract_plot2 &lt;- function(i) {\n  my_tsp &lt;-pento_min$data[[i]] |&gt;\n    mutate(sol_text=as.numeric(fct_reorder(sol_text,x*y,sum))*100) |&gt;\n    dist(\"manhattan\") |&gt;\n    TSP::as.TSP()\n  \n  ### available TSP Method without installing extra\n  methods &lt;- c(\"identity\", \"random\", \"nearest_insertion\",\n               \"cheapest_insertion\", \"farthest_insertion\", \"arbitrary_insertion\",\n               \"nn\", \"repetitive_nn\", \"two_opt\")\n  \n  my_tsp_path &lt;- solve_TSP(my_tsp, method=methods[3]) ## nearest insertion \n  \n  pento_min$data[[i]][as.integer(my_tsp_path),] |&gt;\n    mutate(idx=row_number()) |&gt;\n    ggplot() +\n    geom_arc_bar(aes(x0=x+0.5,y0=y+0.5,r0=0, r=sqrt(1), start=3*pi/2, end=pi, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx%%8==1)) +\n    geom_arc_bar(aes(x0=x-0.5,y0=y-0.5,r0=0, r=sqrt(1), start=0, end=pi/2, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx%%8==2)) +\n    geom_arc_bar(aes(x0=x+0.5,y0=y-0.5,r0=0, r=sqrt(1), start=0, end=-pi/2, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx%%8==3)) +\n    geom_circle(aes(x0=x,y0=y, r=sqrt(0.25),\n                    fill=sol_text), \n                data = . %&gt;% filter(idx%%8==4),\n                color=\"transparent\") +\n    geom_arc_bar(aes(x0=x+0.5,y0=y+0.5,r0=0, r=sqrt(1), start=3*pi/2, end=pi, \n                     fill=sol_text), color=\"transparent\",\n                 data = . %&gt;% filter(idx%%8==5)) +\n    geom_regon(aes(x0=x,y0=y,r=sqrt(0.5),sides=4, fill=sol_text,angle=0), \n               color=\"transparent\",\n               data = . %&gt;% filter(idx%%8==6)) +\n    geom_regon(aes(x0=x,y0=y,r=sqrt(0.5),sides=4, fill=sol_text,angle=0), \n               color=\"transparent\",\n               data = . %&gt;% filter(idx%%8==7)) +\n    geom_regon(aes(x0=x,y0=y,r=sqrt(0.5),sides=4, fill=sol_text,angle=0), \n               color=\"transparent\",\n               data = . %&gt;% filter(idx%%8==0)) +\n    # geom_text(aes(x=x,y=y, label=idx), color=\"#fffff330\",\n    #           family=\"Futura\") +\n    coord_fixed() +\n    scale_fill_manual(values=retro12) +\n    theme_nothing()\n  \n}\n\npento_min |&gt; filter(dim==\"8×8d\") |&gt; \n  pull(solution_num) |&gt;\n  sample(size=6) |&gt;\n  map(abstract_plot2) |&gt;\n  wrap_plots()"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Creating a Seigaha Motif with ggplot2",
    "section": "",
    "text": "The Seigaiha (青海波) motif, literally translated as “blue ocean waves” is a classic Japanese pattern used in textiles, ceramics, kimono and art. It features stylized waves created with concentric circles forming arches. I just learned that it symbolizes surges of good luck - delightful and thought great start to have it for blog post.\n\n青 = Blue\n海 = Ocean\n波 = Wave\n\nUsing ggplot2 and additional packages like ggforce and cowplot, I was able to recreate this timeless design programmatically.\n\n\nFirst need to load up the required libraries. Recently, I discovered package called annotater , which let you add annotation to the packages you use in script! It’s such a useful tool - future me (and anyone collaborating on my code) will likely thank me for using it.\n\n\nCode\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse' \nlibrary(ggforce) # Accelerating 'ggplot2'   \nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'  \nlibrary(gt) # Easily Create Presentation-Ready Display Tables \n\ncol10 &lt;- str_split(\"012a4a-013a63-01497c-014f86-2a6f97-2c7da0-468faf-61a5c2-89c2d9-a9d6e5\",\"-\")\n\ncol10_pal &lt;-str_c(\"#\",col10 |&gt; unlist())\n\n\n\n\n\nWe create a grid of coordinates to serve as the base for our motif. To archieve the characteristic offset of Seigaiha waves, we adjust the x coordinates for odd rows:\n\n\nCode\ndf &lt;- expand_grid(x = seq(-16, 16, by = 2), \n                  y = seq(-10, 10, by = 1)) |&gt;\n  arrange(y,x) |&gt;\n  mutate(y_odd=(y%%2==1)) |&gt;\n  mutate(idx=row_number()-1) |&gt;\n  mutate(x=if_else(y_odd,x+1,x))\n\n\n\n\n\nThe radii of the circles vary in five steps. It could be smaller or larger. I could’ve also add randomness to it too, but I just kept it constant for now.\n\n\nCode\nr_values &lt;- seq(0.3,1.1,length.out=5)\ndf_long &lt;- df |&gt; expand_grid(r=r_values)\n\n\ndf_long &lt;- df_long |&gt;\n  mutate(r_var=if_else(idx%%5==0,sqrt(r),r))\n\n#range(df_long$x)\n#range(df_long$y)\n\ndf_long |&gt; head() |&gt; gt()\n\n\n\n\n\n\n\n\nx\ny\ny_odd\nidx\nr\nr_var\n\n\n\n\n-16\n-10\nFALSE\n0\n0.3\n0.5477226\n\n\n-16\n-10\nFALSE\n0\n0.5\n0.7071068\n\n\n-16\n-10\nFALSE\n0\n0.7\n0.8366600\n\n\n-16\n-10\nFALSE\n0\n0.9\n0.9486833\n\n\n-16\n-10\nFALSE\n0\n1.1\n1.0488088\n\n\n-14\n-10\nFALSE\n1\n0.3\n0.3000000\n\n\n\n\n\n\n\n\n\n\nUsing geom_circle from ggforce, we layer circles over the grid. We map the fill colour to the adjusted radius (r_var) for a slight gradeient effect:\n\n\nCode\ndf_long |&gt;\n  arrange(-y, idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(\n    aes(\n      x0 = x,\n      y0 = y,\n      r = r,\n      fill = r_var ## just wanted to give bit of variance\n    ),\n    linewidth = 0.1,\n    color = \"#fffff3de\",\n    linetype = 3\n  ) +\n  coord_fixed(clip = \"on\",\n              xlim = c(-15, 14.5),\n              ylim = c(-9, 9)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors = col10_pal) +\n  scale_color_gradientn(colors = col10_pal)\n\n\n\n\n\n\n\n\n\n\n\n\nThe theme_nothing() from cowplot removes all unnecessary visual elements (axes, labels etc.), leaving only the motif. I’ve adjusted xlim and ylim so that I’m clipping out the extra circles."
  },
  {
    "objectID": "posts/post-with-code/index.html#seigaiha-青海波",
    "href": "posts/post-with-code/index.html#seigaiha-青海波",
    "title": "Creating a Seigaha Motif with ggplot2",
    "section": "",
    "text": "The Seigaiha (青海波) motif, literally translated as “blue ocean waves” is a classic Japanese pattern used in textiles, ceramics, kimono and art. It features stylized waves created with concentric circles forming arches. I just learned that it symbolizes surges of good luck - delightful and thought great start to have it for blog post.\n\n青 = Blue\n海 = Ocean\n波 = Wave\n\nUsing ggplot2 and additional packages like ggforce and cowplot, I was able to recreate this timeless design programmatically.\n\n\nFirst need to load up the required libraries. Recently, I discovered package called annotater , which let you add annotation to the packages you use in script! It’s such a useful tool - future me (and anyone collaborating on my code) will likely thank me for using it.\n\n\nCode\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse' \nlibrary(ggforce) # Accelerating 'ggplot2'   \nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'  \nlibrary(gt) # Easily Create Presentation-Ready Display Tables \n\ncol10 &lt;- str_split(\"012a4a-013a63-01497c-014f86-2a6f97-2c7da0-468faf-61a5c2-89c2d9-a9d6e5\",\"-\")\n\ncol10_pal &lt;-str_c(\"#\",col10 |&gt; unlist())\n\n\n\n\n\nWe create a grid of coordinates to serve as the base for our motif. To archieve the characteristic offset of Seigaiha waves, we adjust the x coordinates for odd rows:\n\n\nCode\ndf &lt;- expand_grid(x = seq(-16, 16, by = 2), \n                  y = seq(-10, 10, by = 1)) |&gt;\n  arrange(y,x) |&gt;\n  mutate(y_odd=(y%%2==1)) |&gt;\n  mutate(idx=row_number()-1) |&gt;\n  mutate(x=if_else(y_odd,x+1,x))\n\n\n\n\n\nThe radii of the circles vary in five steps. It could be smaller or larger. I could’ve also add randomness to it too, but I just kept it constant for now.\n\n\nCode\nr_values &lt;- seq(0.3,1.1,length.out=5)\ndf_long &lt;- df |&gt; expand_grid(r=r_values)\n\n\ndf_long &lt;- df_long |&gt;\n  mutate(r_var=if_else(idx%%5==0,sqrt(r),r))\n\n#range(df_long$x)\n#range(df_long$y)\n\ndf_long |&gt; head() |&gt; gt()\n\n\n\n\n\n\n\n\nx\ny\ny_odd\nidx\nr\nr_var\n\n\n\n\n-16\n-10\nFALSE\n0\n0.3\n0.5477226\n\n\n-16\n-10\nFALSE\n0\n0.5\n0.7071068\n\n\n-16\n-10\nFALSE\n0\n0.7\n0.8366600\n\n\n-16\n-10\nFALSE\n0\n0.9\n0.9486833\n\n\n-16\n-10\nFALSE\n0\n1.1\n1.0488088\n\n\n-14\n-10\nFALSE\n1\n0.3\n0.3000000\n\n\n\n\n\n\n\n\n\n\nUsing geom_circle from ggforce, we layer circles over the grid. We map the fill colour to the adjusted radius (r_var) for a slight gradeient effect:\n\n\nCode\ndf_long |&gt;\n  arrange(-y, idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(\n    aes(\n      x0 = x,\n      y0 = y,\n      r = r,\n      fill = r_var ## just wanted to give bit of variance\n    ),\n    linewidth = 0.1,\n    color = \"#fffff3de\",\n    linetype = 3\n  ) +\n  coord_fixed(clip = \"on\",\n              xlim = c(-15, 14.5),\n              ylim = c(-9, 9)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors = col10_pal) +\n  scale_color_gradientn(colors = col10_pal)\n\n\n\n\n\n\n\n\n\n\n\n\nThe theme_nothing() from cowplot removes all unnecessary visual elements (axes, labels etc.), leaving only the motif. I’ve adjusted xlim and ylim so that I’m clipping out the extra circles."
  },
  {
    "objectID": "posts/pentomino/pentomino_part4.html",
    "href": "posts/pentomino/pentomino_part4.html",
    "title": "Pentomino Solution & Patchwork",
    "section": "",
    "text": "Pentomino Solution as igraph object\nIn this post, I’m taking deeper dive into a dataset of Pentomino puzzle solutions using R. This time, I’m switching gears from the sf package, but to explore graph theory concepts with tidygraph and ggraph. Why? Because Pentomino solutions aren’t just puzzles; they’re networks waiting to be uncovered! 🌐\nWhat’s on the menu? 🍴\n\nData Wrangling with tidyverse\nGraphs and graph-based data structures with tidygraph and visualization with ggraph\nArranging Multiple Plots effortlessly with patchwork. The wrap_plots() function function was a lifesaver, sparing me from the monotony of typing plot1 + plot2 + … repeatedly! 🙌\n\n\n\nSetups and Pakcages Used\n# Load required libraries\nlibrary(tidyverse)    # Data wrangling and general utilities\nlibrary(ggraph)       # Graph visualization\nlibrary(tidygraph)    # Graph data structure (tbl_graph) + graph algorithms\nlibrary(ggforce)      # Extra geoms for ggplot2\nlibrary(cowplot)      # Additional plotting helpers\nlibrary(patchwork)    # Combine multiple ggplots effortlessly!\n\n\n\n\nOriginal Solution Dataset\nI’ve saved solution as csv file from earlier blog posts. So just retriving the dataset. Solution looks like below.\n\n\nReading Solution Dataset\n### Read solution data frame from Github \npento_sol &lt;- read_csv(\"https://raw.githubusercontent.com/chichacha/pentomino/refs/heads/main/pentomino_solution.csv\")\n\nsample_n(pento_sol, size=5) |&gt;\n  knitr::kable(\"markdown\")\n\n\n\n\n\n\n\n\n\n\n\n\ndim\nsol_text\nrow_cnt\ncol_cnt\nsol_idx\n\n\n\n\n5×10\nLLLLTTTNNN UUULWTNNFF UPUWWTYFFV PPWWYYYYFV PPIIIIIVVV\n5\n10\n5427\n\n\n6×10\nIIIIIXYYYY VVVFXXXNYW VTFFFXNNWW VTTTFZNWWP UTUZZZNLPP UUUZLLLLPP\n6\n10\n707\n\n\n5×9\nIIIIIFVVV UUPPFFFTV UPPPZZFTV UUNNZLTTT NNNZZLLLL\n5\n9\n1024\n\n\n8×8d\n.FFNNNX. FFNNYXXX IFYYYYXT ILLLLTTT IVVVLWWT IVZZWWPP IVZUWUPP .ZZUUUP.\n8\n8\n133\n\n\n5×11\nLLLLFZZNTTT LXFFFVZNNTY XXXFPVZZNTY UXUPPVVVNYY UUUPPIIIIIY\n5\n11\n2837\n\n\n\n\n\n\nJust prepping colors\nTo make our graphs visually fun, I’m just using retro-inspired color palette and assign unique colors to each Pentomino piece.\n\n\nPrepping Color Palette\n# Just Prepping some color palette\nretro &lt;-  c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\nretro12 &lt;- colorRampPalette(retro)(12)\nretro13 &lt;- c(retro12,\"#ffffff\")\n\n#Assigning names to each color allows direct mapping with scale_color_manual() or scale_fill_manual()\npiece &lt;- c(\"F\",\"I\",\"L\",\"N\",\"P\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\")\nnames(retro12) &lt;- piece\nnames(retro13) &lt;- c(piece,\".\")\n\nretro12 |&gt; enframe() |&gt;\n  ggplot(aes(x=name,y=1)) +\n  geom_tile(aes(fill=I(value))) +\n  geom_text(aes(label=name), color=\"white\",vjust=-0.5) +\n  geom_text(aes(label=value), color=\"white\",vjust=1, size=3) +\n  theme_nothing()\n\n\n\n\n\n\n\n\n\n\n\n\nConverting Solution to (x,y) Positions 📐\nNext, we’ll transform each solution into (x, y) coordinates. This step is crucial for graph creation. I’ve listed a visualization & table of some 3x5 Pentomino solutions, mapped to their (x, y) position.\n\n\nConverting Solution Texts to Data Frame with Coordinates\n### Convert Solution to XY position data frame\npento_sol_df &lt;- pento_sol |&gt;\n  mutate(solution_num = row_number()) |&gt;\n  mutate(sol_text = str_split(sol_text, \" \")) |&gt;\n  unnest(sol_text) |&gt;\n  group_by(solution_num) |&gt;\n  mutate(y = row_number()) |&gt;\n  ungroup() |&gt;\n  mutate(sol_text = str_split(sol_text, \"\")) |&gt;\n  unnest(sol_text) |&gt;\n  group_by(solution_num, y) |&gt;\n  mutate(x = row_number()) |&gt;\n  ungroup()\n\n\n# Split the data into chunks programmatically\ntables &lt;- pento_sol_df |&gt; \n  filter(dim == \"5×3\", sol_idx == 1) |&gt;\n  select(dim, sol_text, x, y) |&gt;\n  group_split(x)\n\npento_sol_df |&gt; \n  filter(dim == \"5×3\", sol_idx %in% c(1:6)) |&gt;\n  mutate(sol_idx=if_else(sol_idx==1, str_c(\"1. See Table Below\"), as.character(sol_idx))) |&gt;\n  ggplot(aes(x=x,y=y)) +\n  geom_point(aes(color=sol_text),size=10) +\n  geom_text(aes(label=sol_text), color=\"#fffff3\") +\n  scale_color_manual(values=retro12, guide=\"none\") +\n  theme_minimal() +\n  facet_wrap(~sol_idx,ncol=6) +\n  coord_fixed() +\n  scale_x_continuous(expand=expansion(add=1)) +\n  scale_y_continuous(expand=expansion(add=1))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndim\nsol_text\nx\ny\n\n\n\n\n5×3\nL\n1\n1\n\n\n5×3\nL\n1\n2\n\n\n5×3\nL\n1\n3\n\n\n5×3\nL\n1\n4\n\n\n5×3\nV\n1\n5\n\n\n\n\n\n\n\n\ndim\nsol_text\nx\ny\n\n\n\n\n5×3\nL\n2\n1\n\n\n5×3\nN\n2\n2\n\n\n5×3\nN\n2\n3\n\n\n5×3\nN\n2\n4\n\n\n5×3\nV\n2\n5\n\n\n\n\n\n\n\n\ndim\nsol_text\nx\ny\n\n\n\n\n5×3\nN\n3\n1\n\n\n5×3\nN\n3\n2\n\n\n5×3\nV\n3\n3\n\n\n5×3\nV\n3\n4\n\n\n5×3\nV\n3\n5\n\n\n\n\n\n\n\n\nStoring the Solution in Nested Table\nUse nest(.by = c(solution_num, dim)) to store each solution’s data in a list column. That way, each row in pento_min corresponds to one puzzle solution, containing the relevant (x, y, sol_text) data in a nested data frame.\n\n\nStore solution in nested way\npento_min &lt;- pento_sol_df |&gt;\n  filter(sol_text != \".\") |&gt;  # exclude the \".\" cells\n  select(x, y, sol_text, solution_num, dim) |&gt;\n  nest(.by = c(solution_num, dim))\n\n\n\n\nCreating Graphs with tidygraph & ggraph 📈\nTo visualize the connections between pieces, we’ll use tidygraph to create graph objects and ggraph for plotting.\n\nFunction: Data Frame to Graph Conversion\nThis function converts a solution’s data frame into a graph by identifying adjacent cells.\n\n\nConvert Data Frame to igraph Object\ndf_to_graph &lt;- function(data) {\n  \n  # cross join is expensive, but straightforward: \n  # generate all pairs of cells, then filter to pairs that are adjacent (Manhattan distance = 1).\n  tmp &lt;- data |&gt;\n    cross_join(data) |&gt;\n    filter((abs(x.x - x.y) + abs(y.x - y.y)) == 1) |&gt;\n    distinct()\n  \n  edges &lt;- tmp |&gt;\n    transmute(\n      from = paste(x.x, y.x, sol_text.x, sep = \",\"),\n      to   = paste(x.y, y.y, sol_text.y, sep = \",\"),\n      w    = if_else(sol_text.x == sol_text.y, 1, 0.1)\n    )\n  \n  # Standardize from/to to avoid duplicate edges in undirected graph\n  edges_unique &lt;- edges %&gt;%\n    rowwise() %&gt;%\n    mutate(\n      a = min(from, to),\n      b = max(from, to)\n    ) %&gt;%\n    ungroup() %&gt;%\n    distinct(a, b, .keep_all = TRUE) %&gt;%\n    select(-a, -b)\n  \n  graph &lt;- tidygraph::as_tbl_graph(edges_unique, directed = FALSE)\n  \n  # Add node attributes\n  graph &lt;- graph |&gt;\n    mutate(\n      x     = as.numeric(str_split_i(name, \",\", 1)),\n      y     = as.numeric(str_split_i(name, \",\", 2)),\n      piece = str_split_i(name, \",\", 3)\n    ) |&gt;\n    mutate(\n      deg   = centrality_degree(weights = w),\n      btwn  = centrality_betweenness(weights = w),\n      sub_g = centrality_subgraph(),\n      idx   = row_number()\n    )\n  \n  return(graph)\n}\n\n\n\n\nFunction: Graph Visualization\nThis function plots the graph using ggraph and highlights adjacency within pieces.\n\n\nVisualizing igraph object with ggraph\nplot_graph &lt;- function(g) {\n  g |&gt;\n    activate(\"nodes\") |&gt;\n    mutate(comm = group_louvain(weights = w)) |&gt;\n    ggraph(layout = \"manual\", x = x, y = y) +\n    \n    # 1) Thicker edges for cells in the same piece\n    geom_edge_link(\n      lineend = \"round\", linejoin = \"mitre\", alpha = 0.8,\n      aes(edge_color = .N()$piece[from], edge_width = I(if_else(w == 1, 7, w)))\n    ) +\n    \n    # 2) Another edge layer (white dash) just as decoration\n    geom_edge_link(\n      lineend = \"square\", linejoin = \"round\", alpha = 0.8,\n      aes(edge_width = I(w)), color = \"#ffffff\", linetype = 3\n    ) +\n    \n    coord_fixed() +\n    theme_nothing() +\n    scale_edge_color_manual(values = retro12) +\n    scale_x_continuous(expand = expansion(add = 1)) +\n    scale_y_reverse(expand = expansion(add = 1))\n  \n}\n\n\n\n\n\nWrapping It Up with patchwork 🖼️\nFinally, let’s use patchwork to combine multiple graphs into a single layout.\n\n\nUtilizing wrap_plot function\nindexes &lt;- c(14369:15378) |&gt; sample(size = 24)\n\nlist_of_plots &lt;- indexes %&gt;%\n  map(~ {\n    pento_min$data[[.x]] %&gt;%\n      df_to_graph() %&gt;%\n      plot_graph()\n  })\n\nwrap_plots(list_of_plots, ncol = 3) +\n  plot_annotation(\n    title = \"Collection of Pentomino Solutions (5x12)\",\n    theme = theme(text = element_text(family = \"Roboto Condensed\"))\n  ) +\n  plot_layout()"
  },
  {
    "objectID": "posts/pentomino/pentomino_part2.html",
    "href": "posts/pentomino/pentomino_part2.html",
    "title": "Pentomino Solutions 6x10 Rectangle",
    "section": "",
    "text": "Solving the Puzzle: The 6x10 Pentomino Challenge (with a Big Help)\n\nThe 6x10 pentomino challenge asks you to fit all 12 pieces into a rectangle perfectly—no overlaps, no gaps, just pure geometric magic. There are 2339 unique solutions! My go-to solution site has been isomerdesign.com. In this post, I’m not solving the 6x10 challenge myself, but I’ll visualize some solutions using R & trusty ggplot2.\n\n\nPakcages Used in This Blog Post\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse'\nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'\nlibrary(sf) # Simple Features for R\nlibrary(patchwork) # The Composer of Plots\n\n### Just playing around with color palette\nretro_col_a &lt;- c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\nretro_col_b  &lt;-c(\"#CA0B0B\", \"#EAA109\", \"#71A6AE\", \"#18668C\", \"#06394D\")\nretro_col_c &lt;- c(\"#325A64\", \"#44838F\", \"#68D0BD\", \"#F53F19\", \"#891C29\")\nretro_col_d &lt;- c(\"#241965\", \"#653993\", \"#9F4094\", \"#B73D6E\", \"#F19406\")\nretro_col_e &lt;- c(\"#383431\", \"#79C39E\", \"#EAD1B5\", \"#EE9B69\", \"#E77843\")\nretro_col_f &lt;- c(\"#8E2605\", \"#E54B1F\", \"#FDC018\", \"#628A81\", \"#5F3924\")\nretro_col_g &lt;- c(\"#811638\", \"#0B7978\", \"#FCB632\", \"#F27238\", \"#C32327\")\n\nretro_col &lt;- c(retro_col_b, retro_col_e, retro_col_a, retro_col_d, retro_col_c, retro_col_f, retro_col_g)\n\n\nI started by loading few useful pakages above. tidyverse makes data wrangling simple, while sf helps manage spartial geometries. Additionally I’ve prepped retro-inspired color palettes so that I can give the visuals a nostalgic puzzle game vibes.\n\n\nLoading the Solutions\n\n\nReading Text Solution File\n### Thank you to solution as text! \nsol_df &lt;- read_csv(\"https://isomerdesign.com/Pentomino/6x10/solutions.txt\",\n                   col_names=F)\n### 2339 Solutions included in CSV\n\n### Turn solution into data frame\nmake_coord_df &lt;- function(x){\n  #x &lt;- sol_df$X2[[1]]\n  x &lt;- str_split(str_remove_all(x,\" \"),\"\",simplify=T)\n  matrix(x,nrow=6,ncol=10, byrow=T) |&gt;\n    as_tibble() |&gt;\n    mutate(y=row_number()) |&gt;\n    pivot_longer(-y) |&gt;\n    mutate(x=as.integer(str_extract(name,\"\\\\d+\"))) |&gt;\n    select(x,y,piece=value) |&gt;\n    group_by(piece) |&gt;\n    mutate(x_min=min(x),y_min=min(y),\n           x_max=max(x),y_max=max(y),\n           idx=row_number(x+y),\n           adj_x=x-x_min+1,adj_y=y-y_min+1) |&gt;\n    ungroup()\n}\n\n### df for data frame\nsol_df &lt;- sol_df |&gt; \n  mutate(solution_df = map(X2,make_coord_df))\n\n### df_long for data frame that's unnested\nsol_df_long &lt;- sol_df |&gt; \n  unnest(solution_df)\n\n\nThe solutions are provided in a plain text file, where each solution is represented by 10 strings of characters x 6 rows for each of 2339 solutions for 6x10 rectangle. Each letter corresponds to one of the 12 pentomino pieces. Using this as input, I created a function to process each solution into a structured tibble (data frame).\n\n\nConvert to SF Object\n# Function to turn coordinate as center and conver to square\ncreate_square_fence &lt;- function(x, y) {\n  st_polygon(list(matrix(c(\n    x-0.5, y-0.5,  # Bottom Left\n    x+0.5, y-0.5, #Bottom Right\n    x+0.5, y+0.5, #Top Right\n    x-0.5, y+0.5, #Top Left\n    x-0.5, y-0.5  # Close the polygon by coming back to bottom left\n  ), ncol = 2, byrow = TRUE)))\n}\n\n### Convert data frame into sf object\nsol_sf &lt;- sol_df_long |&gt;\n  rowwise() |&gt;\n  # For each row, create a square geometry from the x, y coordinate\n  mutate(geometry=list(create_square_fence(x,y)),\n         geometry_adj=list(create_square_fence(adj_x,adj_y))) |&gt;\n  ungroup() |&gt; # Remove rowwise grouping\n  group_by(X1,piece) |&gt;\n  summarise(geometry=st_union(st_sfc(geometry)),.groups=\"drop\",\n            geometry_adj=st_union(st_sfc(geometry_adj),.groups=\"drop\")) |&gt;\n  st_sf() \n\n\npieces_63 &lt;-sol_sf |&gt;\n  st_drop_geometry() |&gt;\n  count(piece,geometry_adj,sort=T) |&gt;\n  arrange(piece) |&gt;\n  mutate(i=row_number()) |&gt;\n  mutate(col=colourvalues::color_values(i,farver::decode_colour(retro_col)))\n\nsol_sf_comb &lt;- sol_sf |&gt; \n  inner_join(pieces_63 |&gt; select(col,geometry_adj,piece))\n\n\nOnce the data frame was ready, next step was to convert it into sf geometries for spatial analysis and visualization. Here’s how I’ve tackled it.\n\nSquare Polygons: I wrote a small helper function to create a square polygon for each (x,y) coordinate. Each square represents a single unit of the pentomino square pieces.\nMerging into Shapes: To represent entire pentomino pieces, I’ve combined all individual square polygons for a piece into a single shape using st_union().\n\nNormalized Geometry for Variations:\n\n\n\nPentomino pieces can appear in up to 8 variations (rotations and flips). For example, a single piece might have multiple “faces”, depending on how it’s oriented in the solution.\nTo identify which variations of a piece was used in each solution, I created adjusted geometries by aligning the shapes relative to their bounding boxes.\n\n\n\nHeatmap of Pentomino Placement Patterns\nWith the 2339 Solutions processed and converted into geometries, I decided to analyze where each pentomino piece tends to appear on the board. The result is the heatmap you see below.\nThe code using geom_tile() to represent the frequency of each piece at each (x,y) position across all solutions. A facet is created for each pentomino piece, so we can see the pattern differences.\n\n\nHeatmap of Pentomino Placement Patterns\nsol_df_long |&gt;\n  count(x,y,piece) |&gt;\n  ggplot(aes(x=x,y=y)) +\n  geom_tile(aes(fill=n)) +\n  coord_fixed() +\n  facet_wrap(~piece) +\n  scale_fill_viridis_c(option=\"F\",trans=\"sqrt\",\"apperence\") +\n  theme_map(font_family=\"Roboto Condensed\")\n\n\n\n\n\n\n\n\n\n\nInsights from the Heatmap\n\nX Stays Central: The X-piece avoids edges entirely, sticking to the middle where it fits best.\nI Loves the Left Edges: The I-piece often hugs the edges, but there are a few spaces it avoids altogether.\nF and W Are Versatile: These flexible shapes show up all over, but slight tendency towards the center\nV and Y Favor the Edges: Their hook-like shapes are perfect for corners and boundaries.\nT Favors the Top Left: The T-piece seems to favour the top left-corner according to the heatmap.\nZ Leans Asymmetrically: Z leans to one side, and more likely to stay away from the edges.\nL Sticks to Edges: These elongated shapes often sit along the board’s boundaries, especially the bottom left.\nP and U Fits Everywhere: the P-piece slots into difference places.\n\n\n\n\nRecapping the Shapes\n\n\nPiece Shapes Recap\np_sep &lt;-pieces_63 |&gt;\n  group_by(piece) |&gt;\n  mutate(j=row_number(i)) |&gt;\n  st_sf() |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col)),color=\"#fffff3\") +\n  facet_grid(j~piece) +\n  theme_nothing()\n  #theme_minimal()\n\np_stack &lt;-pieces_63 |&gt;\n  group_by(piece) |&gt;\n  mutate(j=row_number(i)) |&gt;\n  st_sf() |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col)),color=\"#fffff3\") +\n  geom_sf_text(aes(label=piece, \n                   geometry=geometry_adj+c(0,3)),\n               family=\"American Typewriter\", size=5,\n               data = . %&gt;% filter(j==1)) +\n  facet_grid(~piece) +\n  theme_nothing() \n\np_sep + p_stack + plot_layout(ncol=1, heights=c(4,1))\n\n\n\n\n\n\n\n\n\nIn above I created a visualization to recap the 12 pentomino shapes, each column shows different variations of piece faces. There are 12 free pieces, but 63 fixed pieces.\n\n\nSome Solutions !\nSince it’s bit hard to display all the solution at once… I’ve first chosen these 12 special solutions. These 12 solutions are particularly interesting because they belong to 3 unique sets where the pieces remain in their default orientation—no flipping or rotation is required! Within each set, there are 4 solutions that differ only in the arrangement of the pieces on the board.\n\n\nSpecial 12 Solutions (3 Sets x 4 Solutions)\nsol_by_color &lt;-sol_sf_comb |&gt;\n  st_drop_geometry() |&gt;\n  group_by(X1) |&gt;\n  summarise(col_pal=paste(sort(col),collapse=\",\")) |&gt;\n  ungroup() |&gt;\n  add_count(col_pal) |&gt;\n  arrange(desc(n),col_pal) \n\nsol_sf_comb |&gt; \n  inner_join(sol_by_color) |&gt;\n  filter(n==4) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col))) +\n  facet_wrap(~X1) +\n  theme_map(font_family=\"Roboto Condensed\")\n\n\n\n\n\n\n\n\n\n\n\nAnother Special 9 Solutions (3 Sets x 3 Solutions)\nsol_sf_comb |&gt; \n  inner_join(sol_by_color) |&gt;\n  filter(n==3) |&gt;\n  arrange(col_pal) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col))) +\n  facet_wrap(~fct_inorder(factor(X1))) +\n  theme_map(font_family=\"Roboto Condensed\")\n\n\n\n\n\n\n\n\n\n\n\n180 Solutions where Pair Exists\nsol_sf_comb |&gt; \n  inner_join(sol_by_color) |&gt;\n  filter(n==2) |&gt;\n  arrange(col_pal) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col))) +\n  facet_wrap(~fct_inorder(factor(X1)),ncol=18) +\n  theme_nothing(font_family=\"Roboto Condensed\") \n\n\n\n\n\n\n\n\n\n\n\nWrapping Up 🎁\nVisualizing these solutions has been like uncovering hidden patterns in a puzzle. It’s been pretty fun execise learning to utilize some of function in sf packages too. And most importantly, now I have solution on my blog I can put away the actual puzzle board after the play."
  },
  {
    "objectID": "posts/pentomino/index.html",
    "href": "posts/pentomino/index.html",
    "title": "What’s a Pentomino Anyway?",
    "section": "",
    "text": "Pakcages Used in This Blog Post\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse'\nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'\nlibrary(sf) # Simple Features for R\nlibrary(patchwork) # The Composer of Plots\n\n\n\nPentominos?\nWhen I was a kid, my dad made a wooden pentomino puzzle which I don’t remember actually solving it (oops!). Many years later, he recreated it with a 3D printer, and while it’s now a plastic version, my puzzle-solving skills haven’t improved much. Whenever I try to put it away, I find myself searching the internet for solutions. So, I thought—why not save some solutions on my blog? BUT, instead of just posting them, I decided to bring pentominos in R to play around.\n\n\nWhat are Pentominos anyway?\nPentominoes are geometric puzzles made up of 12 unique shapes, each consisting of exactly five connected squares. The name comes from the Greek root “penta”, meaning five. The well known Domino 🁓 is 2 connected squares!\nEach piece is named after the letter it resembles—like F, L, T, and Z. The challenge? Fit these pieces together to cover a rectangular board (or other shapes) without overlaps or gaps.\nHere’s a look at the 12 pentomino pieces: \n\n\nCreation of Pentomino Tibble\nBelow is the script to create pentomino_df. Essentially I just recorded coordinates where I should draw a square, so that I can easily draw pentomino pieces with geom_tile function with ggplot2 later!\n\n\nCreation of Individual Pieces as Tibble\nretro_col5 &lt;- c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\n\npentomino_pieces &lt;- list(\n  F = list(c(0,0), c(0,1), c(1,1), c(1,2), c(2,1)),\n  I = list(c(0,0), c(1,0), c(2,0), c(3,0), c(4,0)),\n  L = list(c(0,0), c(1,0), c(2,0), c(3,0), c(3,1)),\n  N = list(c(0,0), c(1,0), c(2,0), c(2,1), c(3,1)),\n  P = list(c(0,0), c(0,1), c(1,0), c(1,1), c(0,2)),\n  T = list(c(0,0), c(0,1), c(0,2), c(1,1), c(2,1)),\n  U = list(c(0,0), c(1,0), c(2,0), c(0,1), c(2,1)),\n  V = list(c(0,0), c(1,0), c(2,0), c(2,1), c(2,2)),\n  W = list(c(0,2), c(1,1), c(1,2), c(2,1), c(2,0)),\n  X = list(c(0,1), c(1,1), c(1,0), c(1,2), c(2,1)),\n  Y = list(c(0,0), c(1,0), c(2,0), c(3,0), c(2,1)),\n  Z = list(c(0,2), c(1,2), c(1,1), c(1,0), c(2,0))\n)\n\n# Convert pentomino pieces into a tibble\npentomino_df &lt;- tibble(\n  piece = names(pentomino_pieces),\n  coords = pentomino_pieces\n) %&gt;%\n  unnest(coords) %&gt;%  # Expand list of coordinates into rows\n  mutate(\n    x = map_dbl(coords, ~ .x[1]),  # Extract x coordinate\n    y = map_dbl(coords, ~ .x[2])   # Extract y coordinate\n  ) %&gt;%\n  select(-coords)  # Remove the original list column\n\n# Assign symmetry type to pieces \npentomino_df &lt;- pentomino_df |&gt;\n  mutate(rotate_options = \n           case_when(piece %in% c(\"X\") ~ 1,\n                     piece %in% c(\"I\") ~ 2,\n                     piece %in% c(\"Z\") ~ 2,\n                     piece %in% c(\"T\",\"U\",\"V\",\"W\") ~ 2,\n                     piece %in% c(\"F\",\"L\",\"N\",\"P\",\"Y\") ~ 4),\n         flip_options = case_when(piece %in% c(\"F\",\"L\",\"N\",\"P\",\"Y\",\"Z\") ~ 2,\n                                  TRUE ~ 1)) |&gt;\n  mutate(group_name = \n           case_when(piece %in% c(\"X\") ~ \"multi-axis\",\n                     piece %in% c(\"I\") ~ \"line-point\",\n                     piece %in% c(\"Z\") ~ \"point\",\n                     piece %in% c(\"T\",\"U\",\"V\",\"W\") ~ \"line\",\n                     piece %in% c(\"F\",\"L\",\"N\",\"P\",\"Y\") ~ \"none\"))\n\n\nWhat’s the use of dataset, if you don’t visualize them? ;)\n\n\nVisualzing Each Pieces with ggplot2\n### using geom_tile to visualize\npentomino_df |&gt;\n  group_by(piece) |&gt;\n  ### I just want to give different color to each square \n  mutate(idx=row_number(x)) |&gt;\n  ggplot(aes(x=x,y=y)) +\n  geom_tile(aes(fill=factor(idx)), color=\"white\") +\n  geom_text(aes(label=str_c(piece,\"\\nsym:\",group_name)),\n            data = . %&gt;% \n              group_by(group_name,piece) %&gt;%\n              summarise(x=max(x)+0.5, y=max(y+1.5)), \n            hjust=1,vjust=1,\n            lineheight=0.8, family=\"Roboto Condensed\") +\n  facet_wrap(~piece+group_name) +\n  scale_fill_manual(values=retro_col5) +\n  theme_nothing() +\n  coord_fixed()  +\n  theme(plot.background=element_rect(fill=\"#fffff3\", color=\"#fffff300\"))\n\n\n\n\n\n\n\n\n\n\n\nFrom Blocks to Geometry: Converting Pentominoes into Spatial Data\nWhen working with spatial data, converting objects into simple features opens up possibilities for spatial analysis and visualization. The sf package in R provides a user-friendly and standardized way to handle geometric shapes and spatial attributes.\nSimple features represent spatial data as geometries (like points, lines, and polygons) alongside their associated attributes. So here’s how I’ve converted data frame with 60 rows into 12 rows with geometry column.\n\n\nCreating sf object\n# Function to create a square polygon from a coordinate\n# Each coordinate represents the bottom-left corner of a square\ncreate_square &lt;- function(x, y) {\n  st_polygon(list(matrix(c(\n    x, y,  # Bottom Left\n    x + 1, y, #Bottom Right\n    x + 1, y + 1, #Top Right\n    x, y + 1, #Top Left\n    x, y  # Close the polygon by coming back to bottom left\n  ), ncol = 2, byrow = TRUE)))\n}\n\n# Step-by-step process to convert pentomino data into an sf object\npentomino_sf &lt;- pentomino_df |&gt;\n  rowwise() |&gt;\n  # For each row, create a square geometry from the x, y coordinate\n  mutate(geometry=list(create_square(x,y))) |&gt;\n  ungroup() |&gt; # Remove rowwise grouping\n  group_by(piece) |&gt;\n  # Group all square geometries for each pentomino piece into a single shape\n  summarise(geometry=st_union(st_sfc(geometry)),.groups=\"drop\") |&gt;\n  # Convert the summarised data into an sf object\n  st_sf() \n\n# Write it out as geojson for future use\n#pentomino_sf |&gt; \n  #st_write(fs::path(here::here(),\"posts\",\"pentomino\",\"pentomino_sf.geojson\"))\n\npentomino_sf \n\n\nSimple feature collection with 12 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 0 ymin: 0 xmax: 5 ymax: 3\nCRS:           NA\n# A tibble: 12 × 2\n   piece                                                            geometry\n   &lt;chr&gt;                                                           &lt;POLYGON&gt;\n 1 F     ((0 0, 0 1, 0 2, 1 2, 1 3, 2 3, 2 2, 3 2, 3 1, 2 1, 1 1, 1 0, 0 0))\n 2 I     ((0 1, 1 1, 2 1, 3 1, 4 1, 5 1, 5 0, 4 0, 3 0, 2 0, 1 0, 0 0, 0 1))\n 3 L     ((0 1, 1 1, 2 1, 3 1, 3 2, 4 2, 4 1, 4 0, 3 0, 2 0, 1 0, 0 0, 0 1))\n 4 N     ((0 1, 1 1, 2 1, 2 2, 3 2, 4 2, 4 1, 3 1, 3 0, 2 0, 1 0, 0 0, 0 1))\n 5 P               ((0 1, 0 2, 0 3, 1 3, 1 2, 2 2, 2 1, 2 0, 1 0, 0 0, 0 1))\n 6 T     ((0 0, 0 1, 0 2, 0 3, 1 3, 1 2, 2 2, 3 2, 3 1, 2 1, 1 1, 1 0, 0 0))\n 7 U     ((0 1, 0 2, 1 2, 1 1, 2 1, 2 2, 3 2, 3 1, 3 0, 2 0, 1 0, 0 0, 0 1))\n 8 V     ((0 1, 1 1, 2 1, 2 2, 2 3, 3 3, 3 2, 3 1, 3 0, 2 0, 1 0, 0 0, 0 1))\n 9 W     ((3 0, 2 0, 2 1, 1 1, 1 2, 0 2, 0 3, 1 3, 2 3, 2 2, 3 2, 3 1, 3 0))\n10 X     ((2 0, 1 0, 1 1, 0 1, 0 2, 1 2, 1 3, 2 3, 2 2, 3 2, 3 1, 2 1, 2 0))\n11 Y     ((0 1, 1 1, 2 1, 2 2, 3 2, 3 1, 4 1, 4 0, 3 0, 2 0, 1 0, 0 0, 0 1))\n12 Z     ((1 1, 1 2, 0 2, 0 3, 1 3, 2 3, 2 2, 2 1, 3 1, 3 0, 2 0, 1 0, 1 1))\n\n\n\nPlotting SF Object with geom_sf\nNow that I’ve transformed my pentomino shapes into sf objects, it’s time to explore the magical world of geometric unary operations! Unary operation is an operation that acts on a single geometric shape to derive a new geometry.\nIn below, I’m playing around with visualizing my pentomino pieces in layers. Each layer has its own unique touch, an inflated buffer, a deflated outline, as well as the original piece.\nColour of pieces are separated by sysmetry groups. FLNPY pieces are asymetric pieces, while TUVW has line symmetry and so on.\n\n\nPlotting SF object with geom_sf\n# Quickly Plotting Out with geom_sf\npentomino_sf |&gt;\n  left_join(pentomino_df |&gt; select(piece,group_name)) |&gt;\n  ggplot() +\n  ### puffing it with bigger positive number\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=1)),\n          alpha=0.05, color=\"snow\") +\n  ### puffing the geometry by 0.25 to give them little bubble\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=0.25)),\n          alpha=0.3) +\n  ### original shape of pentomino pieces\n  geom_sf(aes(fill=group_name),color=\"white\") +\n  ### deflating just a bit and making it look like stiches\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=-0.2)),\n          color=\"white\",linetype=3) +\n  ### deflating closer to the core\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=-0.45)),\n          color=\"white\",linetype=1) +\n  facet_wrap(~piece) +\n  scale_fill_manual(values=retro_col5) +\n  theme_minimal_grid(font_family=\"Roboto Condensed\") +\n  labs()\n\n\n\n\n\n\n\n\n\n\n\nUsing Minimum Rotated Rectangle\nNext up, I just decide to wrap each pentomino in its neatest, smallest rectangle. This is if I were to wrap each pieces in gift wrap. 🎁 The number displayed is the area of rectangle.\nThese rectangles reveal how tightly we can enclose shapes, which is useful in applications like spatial optimization or determining object orientation in real-life scenario.\n\n\nUsing st_minimum_rotate_rectangle\n# Rotate x degrees around (0,0)\nrot &lt;- function(a) {\n  a = a*(pi/180)\n  matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2)\n}\n\n# Visualize pentomino pieces with their minimum rotated rectangles\nbox_me_up &lt;- function(angle,...) {\n  pentomino_sf |&gt;\n  mutate(geometry=geometry*rot(angle)) |&gt; \n  mutate(mrr_area = st_area(st_minimum_rotated_rectangle(geometry))) |&gt;\n  left_join(pentomino_df |&gt; select(piece,group_name)) |&gt;\n  ggplot() +\n  # Plot rotated rectangles around each shape\n  geom_sf(aes(fill=factor(mrr_area),\n              geometry=st_minimum_rotated_rectangle(geometry)),\n          alpha=0.1,linetype=3, color=\"black\") +\n  # Plot original pentomino shapes \n  geom_sf(aes(fill=factor(mrr_area)),color=\"white\",alpha=0.9) +\n  geom_sf_text(aes(label=mrr_area), family=\"Roboto Condensed\") +\n  facet_wrap(~piece) +\n  scale_fill_manual(values=c(retro_col5,\"#56B870\"),guide=\"none\") +\n  theme_minimal_grid(font_family=\"Roboto Condensed\") +\n  labs(title=str_glue(\"{angle} degree rotated\")) +\n  theme(text=element_text(family=\"Roboto Condensed\"),\n        axis.text=element_blank()) +\n    labs(x=\"\",y=\"\")\n}\n\n\np1 &lt;- box_me_up(90)\np2 &lt;- box_me_up(180)\n\np1 + p2\n\n\n\n\n\n\n\n\n\nAt first, it seemed strange that the F-shape’s rotated rectangle has an area of 9.6, while a simple grid-aligned box could enclose it in an area of 9. The st_minimum_rotated_rectangle function looks for the tightest-fitting rectangle that can enclose the shape. It doesn’t stick to the grid - instead, it tilts the rectangle to snugly fit the shape, even if the result feels counterintuitive? (At least I thought it was counterintuitive…)\n\n\n\nWhere’s the Solutions?\nFor now, I’m wrapping up my geometry experiments (pun intended 🎁).\nI’ll dive into how to fit these pieces together to solve the classic pentomino puzzles - No more googling for a solution in next post."
  },
  {
    "objectID": "posts/2024_12/taco_hat_cake_gift_pizza.html",
    "href": "posts/2024_12/taco_hat_cake_gift_pizza.html",
    "title": "Recreating the Chaos of Taco Hat Cake Gift Pizza in R",
    "section": "",
    "text": "🌮🎩🍰🎁🍕 Taco Hat Cake Gift Pizza with Monkey, Ninja, and Unicorn\nOver the Christmas holiday, my niece and nephew introduced me to Taco Cat Goat Cheese Pizza, a game that’s equal parts chaotic and hilarious. Imagine trying to slap a card while screaming “TACO!” but your hand freezes like it forgot its job. 🖐️🌮\nMy niece and nephew absolutely crushed me — I like to blame that I’ve had one too many cookies and was too slow 🍪🍫🍷.\nBut even in defeat, I had so much fun that I decided I needed a version of this game at home. So, I went ahead and bought Taco Hat Cake Gift Pizza (because, let’s be honest, who can resist a ninja 🥷 and unicorn 🦄?).\n\n\nCrafting the Card Deck\n\n\nPakcages Used in This Blog Post\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse'\nlibrary(ggforce) # Accelerating 'ggplot2'\nlibrary(ggtext) # Improved Text Rendering Support for 'ggplot2'\nlibrary(ggimage) # Use Image in 'ggplot2'\nlibrary(fs) # Cross-Platform File System Operations Based on 'libuv'\n\n\nWhen I opened the game, I found myself fascinated by the simple yet clever design of the card deck. It’s a perfect balance of “base” cards (like Taco, Hat, Cake, Gift, and Pizza) and “special” cards (Monkey, Unicorn and Ninja). Naturally, my data-nerd instincts kicked in, and I thought: Why not recreate this deck as a dataset in R?\nUsing the tidyverse, I created a small dataset to represent the deck. Instead of manually duplicating rows to match the card counts, I used one of my favorite hidden gems in tidyverse: uncount() in tidyr package.\n\n\nCreation of the Card Deck\n# Define the palette\npal5 &lt;- c(taco=\"#2f4858\",hat=\"#33658a\",cake=\"#86bbd8ff\",pizza=\"#f6ae2dff\",gift=\"#f26419\")\nbase_img_path &lt;- path(here::here(),\"posts\",\"2024_12\",\"images\")\n\n# Sample card composition data\ncards_comp &lt;- tibble(\n  card = c(\"Taco\", \"Hat\", \"Cake\", \"Gift\", \"Pizza\", \"Monkey\", \"Ninja\", \"Unicorn\"),\n  emoji = c(\"🌮\", \"🎩\", \"🍰\", \"🎁\", \"🍕\", \"🐵\", \"🥷\", \"🦄\"),\n  emoji_img = c(taco=path(base_img_path,\"taco.png\"),\n                hat=path(base_img_path,\"hat.png\"),\n                cake=path(base_img_path,\"cake.png\"),\n                gift=path(base_img_path,\"gift.png\"),\n                pizza=path(base_img_path,\"pizza.png\"),\n                monkey=path(base_img_path,\"monkey.png\"),\n                ninja=path(base_img_path,\"ninja.png\"),\n                unicorn=path(base_img_path,\"unicorn.png\")),\n  type = c(rep(\"base\",times=5),rep(\"special\",times=3)),\n  count = c(11,11,11,11,11,3,3,3)\n)\n\n###. Here's the power of Uncount function, opposite of dplyr::count()\ncards &lt;- cards_comp |&gt; uncount(count)\n\n### After cards have been unnested, assigning background color\ncards$color &lt;- c(rep(pal5[\"taco\"],times=8),c(pal5[c(\"pizza\",\"gift\",\"hat\")]),\n          rep(pal5[\"hat\"],times=9),c(pal5[c(\"taco\",\"cake\")]),\n          rep(pal5[\"cake\"],times=8),c(pal5[c(\"taco\",\"gift\",\"hat\")]),\n          rep(pal5[\"gift\"],times=8),c(pal5[c(\"pizza\",\"taco\",\"pizza\")]),\n          rep(pal5[\"pizza\"],times=8),c(pal5[c(\"hat\",\"taco\",\"gift\")]),\n          c(pal5[c(\"gift\",\"pizza\",\"hat\")]),\n          c(pal5[c(\"hat\",\"pizza\",\"taco\")]),\n          c(pal5[c(\"taco\",\"cake\",\"hat\")])) \n\n\n\nSpotlight on uncount()\nIf you’ve ever struggled to expand a dataset by repeating rows based on a count column, uncount() is a lifesaver. In just one line, it takes a column like count and automatically duplicates rows the specified number of times. I actually didn’t know this function till fairly recently.\n\n\n\nVisualizing the Card Composition\nWith the deck dataset ready, I couldn’t resist visualizing it. Using ggplot2 and ggimage, I created a colorful layout that shows the composition of cards in Taco Hat Cake Gift Pizza.\nHere’s the plot:\n\n\nLayout Out Base & Special Card\ncards |&gt;\n  arrange(type) |&gt;\n  #slice_sample(n = nrow(cards)) |&gt;\n  #mutate(player=c(rep(c(\"A\",\"B\",\"C\",\"D\",\"E\"),times=12),\"X\",\"X\",\"X\",\"X\")) |&gt;\n  mutate(grp=if_else(type==\"base\",card,type)) |&gt;\n  mutate(grp=fct_inorder(grp)) |&gt;\n  group_by(grp) |&gt;\n  mutate(idx=row_number()) |&gt;\n  ggplot(aes(x=idx,y=grp)) +\n  geom_tile(aes(fill=I(color)), width=0.75, height=0.97) +\n  geom_image(aes(image=emoji_img, by=\"height\"), size=0.1) +\n  coord_fixed() +\n  theme_nothing(base_family=\"Roboto Condensed\") +\n  geom_richtext(aes(x=0,y=grp,\n                    label=str_glue(\"&lt;b&gt;{n}&lt;/b&gt;&lt;br&gt;{grp}&lt;br&gt;cards\")),\n                data = . %&gt;% group_by(grp) %&gt;% summarise(n=n(),det=paste(unique(card),collapse=\"&lt;br&gt;\")),\n                family=\"Roboto Condensed\",\n                fill=\"transparent\",\n                label.colour=\"transparent\") +\n  labs(title=\".    Composition of Cards inside of Taco Hat Cake Gift Pizza\")\n\n\n\n\n\n\n\n\n\n\n\nShuffling the Deck and Dealing to Players 🎲\nOnce the deck was ready, it was time to shuffle and deal. After all, what’s a card game without a bit of randomness? Using slice_sample(), I shuffled the cards, then distributed them to five imaginary players.\nHere’s how the shuffled cards looked when dealt out, with any extra cards forming a “Left Over Pile”:\n\n\nShuffling and Dealing\n# Shuffle the cards\nshuffled_cards &lt;- cards |&gt; \n  slice_sample(n = nrow(cards))\n\nplayer_num &lt;- 5\nshuffled_cards |&gt;\n  mutate(idx=row_number()-1,\n         player = (idx%%player_num)+1) |&gt;\n  mutate(is_left_over=idx&gt;=player_num*12) |&gt;\n  mutate(player=if_else(is_left_over,\"Left Over Pile\",str_c(\"Player \",player))) |&gt;\n  ggplot(aes(x=idx%%4,y=floor((idx%%12)/4))) +\n  geom_tile(aes(fill=I(color)),width=0.97, height=0.97) +\n  geom_image(aes(image=emoji_img, by=\"height\"), size=0.12) +\n  theme_nothing(base_family=\"Roboto Condensed\") +\n  facet_wrap(~player)\n\n\n\n\n\n\n\n\n\n\n\nFinal Thoughts\nRecreating Taco Hat Cake Gift Pizza in R was a fun way to blend coding with a bit of chaos. From shuffling cards to imagining new twists, this exercise now sparked few different ideas on how to utilize this mini dataset — and maybe a few new rules for game night. 🌮🎩🍰"
  },
  {
    "objectID": "posts/2024_12/geometric_pattern_ggplot.html",
    "href": "posts/2024_12/geometric_pattern_ggplot.html",
    "title": "Geometic Art Generator with Shiny",
    "section": "",
    "text": "🌟 Introduction\nggplot2—the trusty workhorse of R. It’s definitely have been the go-to package for creating stunning visualizations for years. And it’s not going anywhere anytime soon. 🎉\nBut I’ve always wondered: What if my ggplot2 creations could come to life? What if I could tweak a slider and instantly see my charts morph? Enter Shiny—a magical tool to make R interactive.\nI procrastinated for years. I finally jumped in. Thanks to tools like shinyapps.io and shinythemes, the process was much smoother than I imagined. These tools took away the stress of deployment and styling, making Shiny approachable even for a beginner like me.\n\n\n🎨 Geometric Generative Art - Shiny App Experimentation\n\n\nCode\ngraph LR\n    A[Static ggplot2 Plot] --&gt; B[Dynamic Shiny App]\n    B --&gt; C[Published on shinyapps.io]\n    C --&gt; D[Embedded in Blog Post]\n\n\n\n\n\ngraph LR\n    A[Static ggplot2 Plot] --&gt; B[Dynamic Shiny App]\n    B --&gt; C[Published on shinyapps.io]\n    C --&gt; D[Embedded in Blog Post]\n\n\n\n\n\n\nTo dip my toes into Shiny, I created an app that lets you experiment with geometric generative art. Adjust sliders to tweak parameters like rotation, scale, and color, and transformation on coordinate system to see how patterns come to life in real time!\n\n\n\n\n\n\nThis app is more of a personal playground for exploring patterns than a polished product. Feel free to experiment!\n\n\n\n\n\n\n\n🎥 From Interactivity to Animation\nAs I played with the app, I wanted to see how parameter changes would look as a sequence. I automated the process to generate frames and stitched them into this animated gif:\n\n\n\n\n✍️ Key Takeaways\nShiny brings interactivity to static ggplot2 visualizations—perfect for both data exploration and presentation.\nTools like shinyapps.io and shinythemes make the process approachable and stylish! I’ve also started exploring newer options like bslib and thematic, which seem promising for even more customization and polished visuals. ✨\nThis one’s probably obvious to seasoned Shiny users. But for me, it was a total lightbulb 💡 moment. Decoupling Shiny app development from the blog itself made everything so much easier, and I wish I’d known this sooner!\nStart with something fun to learn Shiny—because jumping straight into building a business dashboard feels like a much higher hurdle. Experimenting with something playful, like geometric art, makes the learning curve way less intimidating."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CHI(χ)-Files",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nUtiling geom_arc_bar for creation of geometric art\n\n\n\n\n\n\nJanuary 19, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPentomino Solution & Patchwork\n\n\n\n\n\n\nJanuary 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCompact Pentomino Solution : Parquet Magic\n\n\n\n\n\n\nJanuary 12, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nPentomino Solutions 6x10 Rectangle\n\n\n\n\n\n\nJanuary 9, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nWhat’s a Pentomino Anyway?\n\n\n\n\n\n\nJanuary 7, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nRecreating the Chaos of Taco Hat Cake Gift Pizza in R\n\n\n\n\n\n\nJanuary 4, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing 445 Calendar in R\n\n\n\n\n\n\nDecember 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeometic Art Generator with Shiny\n\n\n\n\n\n\nDecember 26, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nFish-Eye Lens Effect with ggplot2\n\n\n\n\n\n\nDecember 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a Seigaha Motif with ggplot2\n\n\n\n\n\n\nDecember 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHello World! The First Post!\n\n\nAn introduction to the Chi-Files blog and its exciting journey trying to learn Quarto.\n\n\n\nDecember 21, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  }
]