[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "🌌 Welcome to the Chi(χ)-Files!\nThis blog follows my data adventures, tech explorations, and creative thinking. 💧\n\n\n🧑‍💻 Who Am I?\nI’m a Data Visualization Specialist whose work spans data science, analytics, and storytelling. I aim to transform raw data into meaningful insights that drive better decision making. I fell in love exploring data using R (with extra special love 💕 for ggplot2), I also love tinkering with SQL, Databricks, as well as utilizing ordinary Microsoft PowerPoints as dynamic storytelling platforms.\n\n\n🫣A Few Fun Facts\n\n🐱 I lean towards more like “cat”—independent, curious, and always exploring, taking pleasure in discoveries.\n🐶 That said, if asked, I’m a dog person. Dogs hold a special place in my heart ❤️, and my furry friend is my constant companion.\n🌊 I’m captivated by waves—from the rolling ocean swells to the invisible rhythms of radio frequencies. I am drawn to patterns especially geometric ones, not simply waves.\n🛸 The name “Chi(χ)-Files” represents my passion for mystery, adventure, and the unknown.\n\n\n\n✍️ Why This Blog?\nThis space showcases my discoveries in data, visualization, and technology. Here you’ll find some professional insights, personal reflections, and likely more of odd creative projects utilizing R in some way. 🎨📊\nThis blog aims to inspire, demonstrating how data can be both functional and beautiful, analytical and artistic. 💡\n\n\n🌊 Join the Journey\nFeel free to explore, share, and connect. Whether you’re a data enthusiast, a curious learner, or seeking inspiration, I hope the Chi-Files resonates with you."
  },
  {
    "objectID": "posts/2024_12/calendar_generator.html",
    "href": "posts/2024_12/calendar_generator.html",
    "title": "Visualizing 445 Calendar in R",
    "section": "",
    "text": "Have You Heard of the 4-4-5 Calendar? 📆\nIf you’ve worked in retail, you might already know that time isn’t always measured in standard months. Enter the 4-4-5 calendar: a reporting tool that divides a year into 12 periods, each organized into quarters of 4, 4, and 5 weeks (i.e. 13 weeks in each quarter). This structure ensures comparability across years by standardizing the length of each reporting period. (But yes, this isn’t perfect either—every 5-6 years, this produces a year with 53 weeks.)\n\n\nWhy Use a 4-4-5 Calendar?\nStandard Gregorian calendars often lead to reporting headaches🤕, especially when months have varying lengths or different counts of weekends. The 4-4-5 calendar solves this by:\n\nAligning periods to weeks, making year-over-year comparisons simpler.\nStandardizing reporting cycles, especially for weekly-driven industries like retail.\nProviding flexibility with alternative formats, such as the 4-5-4 calendar, for specific business needs.\n\nThere’s also a sibling version👧🏻, the 4-5-4 calendar, which I personally prefer because it ensures that American Thanksgiving 🦃🎁 always falls within Period 11. In contrast, the 4-4-5 calendar may place Thanksgiving in Period 11 or 12, depending on the year.\n\n\nBuilding a Custom 4-4-5 Calendar in R\nTo create a reusable tool, I developed the create_calendar function. This function takes a year and a calendar type (“445” or “454”) and returns a detailed tibble with dates, weeks, periods, and quarters. Function takes the year, and returns calendar as data frame.\n\n\nCreate Calendar Function\ncreate_calendar &lt;- function(year, calendar_type = \"445\", col_pal = NULL, ...) {\n  if (is.null(col_pal)) {\n    col_pal &lt;- ggthemes::tableau_color_pal(\"Hue Circle\")(19)[c(1:13)]\n  }\n  \n  cal &lt;- tibble(\n    dt = seq.Date(ymd(paste0(year-1, \"-12-01\")), ymd(paste0(year, \"-12-31\")), by = \"day\")\n  )\n  \n  wpq &lt;- switch(calendar_type,\n                \"445\" = tibble(\n                  wk = 1:53,\n                  p = sort(c(rep(1:12, each = 4), c(3, 6, 9, 12, 12))),\n                  q = sort(c(rep(1:4, each = 13), c(4)))\n                ),\n                \"454\" = tibble(\n                  wk = 1:53,\n                  p = sort(c(rep(1:12, each=4), c(2, 5, 8, 11, 12))),\n                  q = sort(c(rep(1:4, each = 13), c(4)))\n                ),\n                stop(\"Invalid calendar type. Choose '445' or '454'.\")\n  )\n  \n  cal &lt;- cal |&gt;\n    mutate(\n      yr = isoyear(dt),\n      wk = isoweek(dt),\n      wday = wday(dt, label = TRUE,week_start = getOption(\"lubridate.week.start\", 1))\n    ) |&gt;\n    left_join(wpq, by = \"wk\") |&gt;\n    mutate(color_num=wk + p + q) |&gt;\n    mutate(color_wk = colourvalues::color_values(color_num, \n                                                 palette=farver::decode_colour(col_pal))) |&gt;\n    filter(yr==year)\n  \n  return(cal)\n}\n\n\n\n\nMaking the Visual Calendar\nUsing ggplot2, we can create a visual representation of the calendar. The plot organizes weeks within periods and highlights each period in a grid layout.\nI’ve turned this ggplot2 as another function.\n\n\nPlot Calendar Function\nplot_calendar &lt;- function(cal) {\n  cal |&gt;\n    ggplot(aes(x=wday,y=color_num)) +\n    geom_tile(aes(fill=I(color_wk)), color=\"#ffffffde\") +\n    geom_text(aes(label=day(dt),\n                  color=I(if_else(month(dt)==p,\"#ffffff\",\"#e3e3e3\"))),  \n              family=\"Roboto Condensed\") +\n    geom_text(aes(label=str_c(\"W\",wk),color=I(color_wk),x=0),\n              family=\"Roboto Condensed\", \n              data = . %&gt;% count(wk,color_num,color_wk,p,q))+\n    geom_blank(aes(x=-1)) +\n    scale_y_reverse(breaks=NULL) +\n    scale_x_discrete(labels=~str_sub(.,1L,2L)) +\n    facet_wrap(~p,ncol=3, scales=\"free\") +\n    cowplot::theme_minimal_grid(font_family=\"Roboto Condensed\",line_size=0) +\n    labs(x=\"\",y=\"\")\n}\n\n\n\n2025 - 445 🗓️2025 - 454 🗓️2024 - 445 🗓️2024 - 445 🗓️\n\n\n\n\nCode\ncreate_calendar(year=2025, calendar_type=\"445\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreate_calendar(year=2025, calendar_type=\"454\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreate_calendar(year=2024, calendar_type=\"445\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ncreate_calendar(year=2024, calendar_type=\"454\") |&gt;\n  plot_calendar()\n\n\n\n\n\n\n\n\n\n\n\n\nWhile the 4-4-5 calendar does simplifies retail reporting, timekeeping isn’t always that straightforward. I’ve taken things up a notch and explore how sunlight, time zones, and Daylight Saving Time adds extra complexity.\n\n\nUp the Complication of Timekeeping by a Few Notches\nAt first glance, keeping track of time seems simple 💡—but dig deeper, and it’s anything but. Add time zones, daylight saving time (DST), and patterns of sunlight to the mix, and you’ve just cranked the complexity up to expert mode. 😅\nI don’t think I’ve solved this puzzle perfectly yet, but here’s my attempt using R’s suncalc package to visualize sunlight data alongside our trusty 4-4-5 calendar.\n\n\nSunlight Length Plot Creation\n## install.package if you don't have it installed.  \nlibrary(suncalc)\n\n# Predefined city list with lat/lon & timezones.  \n# To see full listing of available timezones, OlsonNames()\n\n### Creation of cities tibble\ncities &lt;- tibble(\n  city = c(\n    \"Vancouver\", \"Toronto\", \"New York\", \"Chicago\", \"Los Angeles\", \n    \"Tokyo\", \"Paris\", \"London\", \"Munich\",\n    \"Sydney\", \"Mumbai\", \"Cape Town\", \"Moscow\", \"São Paulo\",\n    \"Denpasar\", \"Lima\", \"Dubai\", \"Bangkok\", \"Istanbul\",\n    \"Reykjavik\", \"Tromsø\", \"Buenos Aires\", \"Cairo\", \"Anchorage\"\n  ),\n  country = c(\n    \"Canada\", \"Canada\", \"United States\", \"United States\", \"United States\",\n    \"Japan\", \"France\", \"United Kingdom\", \"Germany\",\n    \"Australia\", \"India\", \"South Africa\", \"Russia\", \"Brazil\",\n    \"Indonesia\", \"Peru\", \"United Arab Emirates\", \"Thailand\", \"Turkey\",\n    \"Iceland\", \"Norway\", \"Argentina\", \"Egypt\", \"United States\"\n  ),\n  lat = c(\n    49.246292, 43.65107, 40.712776, 41.878113, 34.052235, \n    35.689487, 48.856613, 51.507222, 48.135124,\n    -33.868820, 19.076090, -33.924870, 55.755825, -23.550520,\n    -8.650000, -12.046374, 25.276987, 13.756331, 41.008240,\n    64.1466, 69.6496, -34.603722, 30.044420, 61.218056\n  ),\n  lon = c(\n    -123.116226, -79.347015, -74.005974, -87.629799, -118.243683, \n    139.691711, 2.352222, -0.1275, 11.581981,\n    151.209290, 72.877426, 18.424055, 37.617298, -46.633308,\n    115.216667, -77.042793, 55.296249, 100.501762, 28.978359,\n    -21.9426, 18.9560, -58.3816, 31.2357, -149.900278\n  ),\n  tz = c(\n    \"America/Vancouver\", \"America/Toronto\", \"America/New_York\", \"America/Chicago\", \n    \"America/Los_Angeles\", \"Asia/Tokyo\", \"Europe/Paris\", \"Europe/London\", \n    \"Europe/Berlin\", \"Australia/Sydney\", \"Asia/Kolkata\", \"Africa/Johannesburg\", \n    \"Europe/Moscow\", \"America/Sao_Paulo\", \"Asia/Makassar\", \"America/Lima\", \n    \"Asia/Dubai\", \"Asia/Bangkok\", \"Europe/Istanbul\",\n    \"Atlantic/Reykjavik\", \"Europe/Oslo\", \"America/Argentina/Buenos_Aires\", \n    \"Africa/Cairo\", \"America/Anchorage\"\n  )\n)\n\n\n\n# Generalized function \nvisualize_sunlight &lt;- function(city_name, year) {\n  # Find city details\n  #city_name &lt;- (\"Vancouver, BC\")\n  #year &lt;- 2025\n  city &lt;- cities %&gt;% filter(city == city_name)\n  if (nrow(city) == 0) stop(\"City not found in predefined list.\")\n  \n  # Get sunlight data for the year\n  \n  sunlight_data &lt;- create_calendar(year = year) %&gt;%\n    pull(dt) %&gt;%\n    map_dfr(~ getSunlightTimes(date = ., lat = city$lat, lon = city$lon, tz = city$tz)) %&gt;%\n    as_tibble()  %&gt;%\n    mutate(\n      daylight_dur = as.duration(sunrise %--% sunset),\n      across(where(is.POSIXct), \n             list(time = ~ lubridate::hms(format(ymd_hms(.), \"%H:%M:%S\"))))\n    )\n  \n  # Add calendar columns\n  sunlight_data &lt;- sunlight_data %&gt;% bind_cols(create_calendar(year = year))\n  \n  # Summarise by Period\n  p_summary &lt;- sunlight_data |&gt;\n  group_by(p) |&gt;\n  summarise(\n    across(c(dt:color_num), list(min = ~min(.), max = ~max(.))),\n    avg_dur = mean(daylight_dur)\n  ) |&gt;\n  mutate(\n    avg_dur_seconds = as.numeric(avg_dur),  # Convert duration to seconds\n    avg_dur_hours = avg_dur_seconds / 3600,  # Convert seconds to hours\n    descr = str_glue(\n      \"P{p}\\n{format(dt_min, '%Y %b %e')} - {format(dt_max, '%Y %b %e')}\\n\",\n      \"Avg Daylight: {round(avg_dur_hours, 2)} hours\"\n    )\n  ) |&gt;\n  relocate(p, descr)\n  \n  # Detect DST start and end\n  dst_info &lt;- tibble(\n    date = sunlight_data$date,\n    is_dst = with_tz(ymd_hms(paste(date, \"00:00:00\")), tzone = city$tz) %&gt;% dst()\n  ) %&gt;% filter(is_dst) %&gt;%\n    filter(max(date)==date|min(date)==date)\n  \n  # Dynamically create subtitle\n  if (nrow(dst_info) == 0) {\n    subtitle &lt;- \"This location does not observe Daylight Saving Time (DST).\"\n  } else {\n    dst_start &lt;- if_else(city$lat&gt;0,min(dst_info$date),max(dst_info$date))\n    dst_end &lt;- if_else(city$lat&gt;0,max(dst_info$date),min(dst_info$date))\n    subtitle &lt;- str_glue(\"DST Starts: {format(dst_start, '%b %e %a (Week %V)')} | DST Ends: {format(dst_end, '%b %e %a (Week %V)')}\")\n  }\n  \n  # Generate the plot\n  ggplot(sunlight_data, aes(x = as.numeric(color_num) + as.numeric(wday) / 7)) +\n    geom_ribbon(aes(ymin = dawn_time, ymax = dusk_time, fill = I(colorspace::lighten(color_wk, 0.7)))) +\n    geom_ribbon(aes(ymin = sunrise_time, ymax = sunset_time, fill = I(color_wk))) +\n    geom_line(aes(y = solarNoon_time), linetype = 3) +\n    scale_x_continuous(breaks = NULL) +\n    cowplot::theme_minimal_vgrid(font_family = \"Roboto Condensed\") +\n    geom_hline(yintercept = max(as.numeric(sunlight_data$sunrise_time)), color = \"black\", linetype = 3) +\n    geom_hline(yintercept = min(as.numeric(sunlight_data$sunrise_time)), color = \"black\", linetype = 3) +\n    geom_hline(yintercept = max(as.numeric(sunlight_data$sunset_time)), color = \"black\", linetype = 3) +\n    geom_hline(yintercept = min(as.numeric(sunlight_data$sunset_time)), color = \"black\", linetype = 3) +\n    scale_y_continuous(\n      labels = ~ hms::as_hms(.),\n      breaks = seq(0, 24 * 3600, by = 3600), # Hourly breaks\n      limits = c(0, 24 * 3600)\n    ) +\n    labs(\n      x = \"\",\n      y = \"\",\n      title = str_glue(\"Sunlight Duration for {city_name} {city$country} ({year}) - 445 Calendar\"),\n      subtitle = subtitle\n    ) +\n    geom_label(aes(x=color_num_min, \n                  y=avg_dur_seconds, label=str_c(\"P\",p,\"\\navg\\n\", round(avg_dur_hours,1),\"\\nhrs\")),\n              data = p_summary, family=\"Roboto Condensed\", \n              lineheight=0.8, hjust=0, fill=\"#ffffff50\")\n}\n\n\n\nVancouver 🇨🇦New York 🇺🇸Munich 🇩🇪Tromsø 🇳🇴Sydney 🇦🇺Tokyo 🇯🇵Denpasar 🇮🇩Cairo 🇪🇬\n\n\nVancouver 🇨🇦🌲⛰️ Daylight Saving Time: DST is observed from March to November. Summer days are long (about 16 hours) while winter days are short (about 8 hours). 👩🏻‍🏫 There are more than twice as many daylight hours on the summer solstice than on the winter one.\n\n\nCode\nvisualize_sunlight(\"Vancouver\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nNew York 🇺🇸🗽🏙 Daylight Saving Time: DST is observed from March to November, just like Vancouver. About 15 hours in the summer and about 9.4 hours in the winter, New York’s patterns are slightly less pronounced than Vancouver’s but still notable.\n\n\nCode\nvisualize_sunlight(\"New York\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nMunich 🇩🇪🍺🏰 Daylight Saving Time: Commences in late March and concludes in late October. Sunlight: Summer days last approximately 16 hours, while winter days last approximately 8.5 hours.\n\n\nCode\nvisualize_sunlight(\"Munich\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nTromsø 🇳🇴❄️🌌 **Tromsø’s graph below is broken due to the sun setting after midnight during the summer (a phenomenon called the midnight sun), and I didn’t think through on these edge cases while creating ggplot2!\nDaylight Saving: Starts last Sunday in March, ends last Sunday in October in Norway. That said, Tromsø (and other places in the Arctic Circle) experience midnight sun and polar night - So DST has no actual practical effect??!\n\n\nCode\nvisualize_sunlight(\"Tromsø\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nSydney 🇦🇺🌊🐨 Daylight Saving: Starts first Sunday in October, ends first Sunday in April as seen on the glitch on visual below. I didn’t quite get the extraction of DST accurately in my function, so subtitle still isn’t accurate… 😅 🙀Another interesting thing I learned is that Not all states observe DST in Australia 🇦🇺! This creates a patchwork of timezones during the summer in Australia!\n\n\nCode\nvisualize_sunlight(\"Sydney\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nTokyo 🇯🇵🏙️🌸 Daylight Saving: Japan doesn’t observe DST (Since 1952). Most of Japan experiences consistent sunrise and sunset times throughout the year, making DST less beneficial.\n\n\nCode\nvisualize_sunlight(\"Tokyo\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nDenpasar 🇮🇩🌴🌊 Like the rest of Indonesia, Bali does not observe DST. The daylight time remains constant throughout the year due to its tropical, equatorial location thoughout the year. So there’s really no need for DST.\n\n\nCode\nvisualize_sunlight(\"Denpasar\", 2025)\n\n\n\n\n\n\n\n\n\n\n\nCairo 🇪🇬🕌🐪 Daylight Saving: Unlike Canada or US, DST transition occurs on Friday in Late April and Thursdays in Late October, instead of more typical Sunday.\n\n\nCode\nvisualize_sunlight(\"Cairo\", 2025)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhere are these cities?\nHere’s a map of the cities I’ve picked in above.\n\n\nInteractive Leaflet Map Code\nlibrary(leaflet)\n\ncities |&gt; \n  filter(city %in% c(\"Tokyo\",\"Denpasar\",\"Vancouver\",\"New York\",\"Munich\",\"Sydney\",\"Cairo\",\"Tromsø\")) |&gt;\n  leaflet() |&gt;\n  addProviderTiles(\"CartoDB.DarkMatter\") |&gt;\n  addMarkers(\n    label = ~city,\n    popup = ~map(paste0(\n    \"&lt;b&gt;\", city, \", \",country, \"&lt;/b&gt;&lt;br&gt;\",\n    \"Lat: \", round(lat, 2), \"&lt;br&gt;\",\n    \"Lon: \", round(lon, 2)\n  ), htmltools::HTML\n  ),\n    labelOptions = labelOptions(\n      style = list(\"font-weight\" = \"bold\", \"color\" = \"white\"),\n      direction = \"auto\",\n      textsize = \"12px\",\n      noHide = TRUE,\n      textOnly = TRUE,\n      sticky = TRUE\n    )\n  )\n\n\n\n\n\n\n\n\nTimekeeping: A Rabbit Hole Worth Falling Into 🐰🕳️\nWhat started as a simple exploration of the 4-4-5 calendar turned into a wild ride through the quirks of time—daylight saving oddities, cultural twists, and even the midnight sun.\nI love these “useless trivias,” but they’re a reminder that time isn’t just ticking numbers on a clock—it’s shaped by geography, culture, and sometimes even political drama. This was a fun wake-up call (pun intended) that time is more complex, and entertaining? than we think!!"
  },
  {
    "objectID": "posts/2024_12/index.html",
    "href": "posts/2024_12/index.html",
    "title": "Fish-Eye Lens Effect with ggplot2",
    "section": "",
    "text": "Fascination with “Warping” …\nThe “fish-eye” lens has always fascinated me. It was my gateway into photography—its quirky, distorted charm never failed to add whimsy to my shots. Some of my favourite memories are capturing our furry friends🐶🐽🐄.\nRecently, I started wondering why not bring that same fish-eye🐟👁️ magic into my data visualizations. While it may not suit business dashboards, it’s perfect for artistic visualizations. With ggplot2’s coord_trans() and its \"pseudo_log\" transformation as inspiration, I decied to push the boundaries and create my first custom transformation.\n\n\nDigression : The Seigaha Motif as a Canvas 🎨\nTo test this idea, I used a Seigaha motif I created the other day. It’s a geometric design with overlapping circles that naturally lends itself to experimentation. I introduced randomness to the colors using irrational numbers as denominators, leveraging R’s modulo operation for real numbers. Just another attempt at creating “pseudo-randomness” in the design.\n\\[\nx \\mod y = x - \\text{floor}\\left(\\frac{x}{y}\\right) \\times y\n\\]\n\nFamous “Irrational” Numbers in Math\n\nGolden Ratio\nThe Golden Ratio is often represented by the Greek letter \\(\\phi\\) and is defined as: \\[\n\\phi = \\frac{1 + \\sqrt{5}}{2}\n\\]\n\n\nSilver Ratio\nThe lesser-known Silver Ratio, represented by \\(\\delta_s\\), is defined as: \\[\n\\delta_s = 1 + \\sqrt{2}\n\\]\n\n\nEuler’s Number\nEuler’s number, represented by \\(e\\), is a fundamental constant in mathematics: \\[\ne = \\exp(1)\n\\] It is approximately \\(e \\approx 2.718\\).\n\n\nCode\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse' \nlibrary(ggforce) # Accelerating 'ggplot2'   \nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'  \nlibrary(gt) # Easily Create Presentation-Ready Display Tables \n\n### just declaring the colour palette here\ncol10 &lt;- str_split(\"001219-005f73-0a9396-94d2bd-e9d8a6-ee9b00-ca6702-bb3e03-ae2012-9b2226\",\"-\")\ncol10_pal &lt;-str_c(\"#\",col10 |&gt; unlist())\n\n### Creating data frame that is basis of layout\ndf &lt;- expand_grid(x = seq(-12, 12, by = 2), \n                  y = seq(-8, 8, by = 1)) |&gt;\n  arrange(y,x) |&gt;\n  mutate(y_odd=(y%%2==1)) |&gt;\n  mutate(idx=row_number()-1) |&gt;\n  mutate(x=if_else(y_odd,x+1,x))\n\n### For each grid location, I want 6 concentric circles\nr_values &lt;- seq(0.1,1,length.out=6)\n\n### Just defining some \"Irregular Numbers\" that I can use with Modulo \ngr &lt;- (1 + sqrt(5)) / 2 ## the golden ratio \nsr &lt;- (1 + sqrt(2)) ##. lesser known silver ratio\neuler_num &lt;- exp(1)\n\ndf_long &lt;- df |&gt; expand_grid(r=r_values) |&gt;\n  mutate(r_var=r*(idx%%sr)+1) ## I'm experimenting here with modulo with pi \n\n\n\n\n\n\nCartesian Coordinates: The Baseline\nHere’s the unaltered design using coord_fixed, maintaining regular Cartesian coordinates.\n\n\nCode\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  #coord_trans(x=\"pseudo_log\",y=\"pseudo_log\",clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nEntering the World of Distortion\n\nPseudo-Log Transformation\nWarping begins with using pseudo_log transformation with coord_trans creates an intriguing distortion:\n\n\nCode\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  coord_trans(x=\"pseudo_log\",y=\"pseudo_log\",clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nCustom Fisheye Transformation\nInspired by radial distortion formula, I’ve attempt to write a custom fisheye transformation.\nk controls the intensity of the distortion.\n\nPositive k = Barrel Distortion (like Fisheye)\nNegative k = Pincusion Distortion (Inverse Fisheye).\nr’ is pronouced as “r prime” \\[\nr′=r⋅(1+k*r^2)\n\\] Here’s the implementation:\n\n\n\nCode\nlibrary(scales)\n\n# Define a fisheye transformation using trans_new\nfisheye_trans &lt;- function(k = 0.01) {\n  trans_new(\n    name = \"fisheye\",\n    transform = function(r) r * (1 + k * r^2),        # Forward transformation\n    inverse = function(r_prime) r_prime / (1 + k * r_prime^2)  # Inverse transformation\n  )\n}\n\n# Create the fisheye transformation object\nfisheye &lt;- fisheye_trans(k = 0.03)\n\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  #coord_trans(x=\"pseudo_log\",y=\"pseudo_log\",clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  coord_trans(x=fisheye, y=fisheye) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\nThe result didn’t quite meet my expectations.. 😅🥹, but it’s a start…!\n\n\n\nExperimenting with Modulus Transformation in scales package 📦\nI also explored transformations like modulus, which yielded effects closer to the fish-eye look I envisioned:\n\n\nCode\n# Define the modulus transformation with a specific parameter (e.g., p = 0.5)\nmod_trans_y &lt;- modulus_trans(p = 0.01)\n\n\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  coord_trans(x=mod_trans_y ,y=mod_trans_y ,clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nCode\nmod_trans_x &lt;- modulus_trans(p = 1.5)\ndf_long |&gt;\n  arrange(-y,idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(aes(x0=x,y0=y,r=r,fill=r_var),\n              linewidth=0.1,color=\"#fffff3de\", linetype=1) +\n  #coord_fixed(clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors=col10_pal) +\n  scale_color_gradientn(colors=col10_pal) +\n  coord_trans(x=mod_trans_x ,y=mod_trans_y ,clip=\"on\", xlim=c(-11,11),ylim=c(-7,7)) +\n  theme(plot.margin=unit(c(0,0,0,0),\"mm\"))\n\n\n\n\n\n\n\n\n\n\n\nFinal Thoughts\nExperimenting with warping in ggplot2 opens up a playful avenue for some quirky visualizations. I’m now thinking what to distort next!"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Hello World! The First Post!",
    "section": "",
    "text": "Every great journey begins with a single step—or in this case, a single post. Really I’m just trying to learn how to use Quarto…\n\n\nThe blog name is a nod to my love of mystery, discovery, and exploration. Data can be like an unsolved case—full of patterns, stories, and hidden gems waiting to be uncovered.\n\n\n\nX-Files\n\n\n\n\n\nIn the Chi-Files, every dataset is a puzzle, and the chi-square statistic is our investigative tool to uncover hidden relationships.\nThe formula for the chi-square statistic is:\n\\[\n\\chi^2 = \\sum \\frac{(O_i - E_i)^2}{E_i}\n\\]\nWhere: - \\(O_i\\) = Observed frequency - \\(E_i\\) = Expected frequency - \\(\\sum\\) = The summation symbol, meaning we sum across all categories.\n\n\n\nSuppose we’re investigating sightings of UFOs 👽 across regions:\n\n\n\n\n\n\n\n\nRegion\nObserved Sightings (\\(O_i\\))\nExpected Sightings (\\(E_i\\))\n\n\n\n\nArea 51\n50\n40\n\n\nRoswell\n70\n60\n\n\nPine Gap\n30\n50\n\n\n\nUsing the chi-square formula, we calculate:\n\\[\n\\chi^2 = \\frac{(50 - 40)^2}{40} + \\frac{(70 - 60)^2}{60} + \\frac{(30 - 50)^2}{50}\n\\]\nThis leads to:\n\\[\n\\chi^2 = \\frac{100}{40} + \\frac{100}{60} + \\frac{400}{50} = 2.5 + 1.67 + 8 = 12.17\n\\]\nIf this value exceeds the critical value, we may conclude there’s something strange going on in these regions… but the truth is out there! 🛸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe chi-square test reveals mysteries hidden in plain data. Use it wisely, and remember: the truth is out there! 🛸\n\n\nVisit Quarto"
  },
  {
    "objectID": "posts/welcome/index.html#welcome-to-the-chi-files",
    "href": "posts/welcome/index.html#welcome-to-the-chi-files",
    "title": "Hello World! The First Post!",
    "section": "",
    "text": "Every great journey begins with a single step—or in this case, a single post. Really I’m just trying to learn how to use Quarto…\n\n\nThe blog name is a nod to my love of mystery, discovery, and exploration. Data can be like an unsolved case—full of patterns, stories, and hidden gems waiting to be uncovered.\n\n\n\nX-Files\n\n\n\n\n\nIn the Chi-Files, every dataset is a puzzle, and the chi-square statistic is our investigative tool to uncover hidden relationships.\nThe formula for the chi-square statistic is:\n\\[\n\\chi^2 = \\sum \\frac{(O_i - E_i)^2}{E_i}\n\\]\nWhere: - \\(O_i\\) = Observed frequency - \\(E_i\\) = Expected frequency - \\(\\sum\\) = The summation symbol, meaning we sum across all categories.\n\n\n\nSuppose we’re investigating sightings of UFOs 👽 across regions:\n\n\n\n\n\n\n\n\nRegion\nObserved Sightings (\\(O_i\\))\nExpected Sightings (\\(E_i\\))\n\n\n\n\nArea 51\n50\n40\n\n\nRoswell\n70\n60\n\n\nPine Gap\n30\n50\n\n\n\nUsing the chi-square formula, we calculate:\n\\[\n\\chi^2 = \\frac{(50 - 40)^2}{40} + \\frac{(70 - 60)^2}{60} + \\frac{(30 - 50)^2}{50}\n\\]\nThis leads to:\n\\[\n\\chi^2 = \\frac{100}{40} + \\frac{100}{60} + \\frac{400}{50} = 2.5 + 1.67 + 8 = 12.17\n\\]\nIf this value exceeds the critical value, we may conclude there’s something strange going on in these regions… but the truth is out there! 🛸\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe chi-square test reveals mysteries hidden in plain data. Use it wisely, and remember: the truth is out there! 🛸\n\n\nVisit Quarto"
  },
  {
    "objectID": "posts/pentomino/pentomino_part2.html",
    "href": "posts/pentomino/pentomino_part2.html",
    "title": "Pentomino Solutions 6x10 Rectangle",
    "section": "",
    "text": "Solving the Puzzle: The 6x10 Pentomino Challenge (with a Big Help)\n\nThe 6x10 pentomino challenge asks you to fit all 12 pieces into a rectangle perfectly—no overlaps, no gaps, just pure geometric magic. There are 2339 unique solutions! My go-to solution site has been isomerdesign.com. In this post, I’m not solving the 6x10 challenge myself, but I’ll visualize some solutions using R & trusty ggplot2.\n\n\nPakcages Used in This Blog Post\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse'\nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'\nlibrary(sf) # Simple Features for R\nlibrary(patchwork) # The Composer of Plots\n\n### Just playing around with color palette\nretro_col_a &lt;- c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\nretro_col_b  &lt;-c(\"#CA0B0B\", \"#EAA109\", \"#71A6AE\", \"#18668C\", \"#06394D\")\nretro_col_c &lt;- c(\"#325A64\", \"#44838F\", \"#68D0BD\", \"#F53F19\", \"#891C29\")\nretro_col_d &lt;- c(\"#241965\", \"#653993\", \"#9F4094\", \"#B73D6E\", \"#F19406\")\nretro_col_e &lt;- c(\"#383431\", \"#79C39E\", \"#EAD1B5\", \"#EE9B69\", \"#E77843\")\nretro_col_f &lt;- c(\"#8E2605\", \"#E54B1F\", \"#FDC018\", \"#628A81\", \"#5F3924\")\nretro_col_g &lt;- c(\"#811638\", \"#0B7978\", \"#FCB632\", \"#F27238\", \"#C32327\")\n\nretro_col &lt;- c(retro_col_b, retro_col_e, retro_col_a, retro_col_d, retro_col_c, retro_col_f, retro_col_g)\n\n\nI started by loading few useful pakages above. tidyverse makes data wrangling simple, while sf helps manage spartial geometries. Additionally I’ve prepped retro-inspired color palettes so that I can give the visuals a nostalgic puzzle game vibes.\n\n\nLoading the Solutions\n\n\nReading Text Solution File\n### Thank you to solution as text! \nsol_df &lt;- read_csv(\"https://isomerdesign.com/Pentomino/6x10/solutions.txt\",\n                   col_names=F)\n### 2339 Solutions included in CSV\n\n### Turn solution into data frame\nmake_coord_df &lt;- function(x){\n  #x &lt;- sol_df$X2[[1]]\n  x &lt;- str_split(str_remove_all(x,\" \"),\"\",simplify=T)\n  matrix(x,nrow=6,ncol=10, byrow=T) |&gt;\n    as_tibble() |&gt;\n    mutate(y=row_number()) |&gt;\n    pivot_longer(-y) |&gt;\n    mutate(x=as.integer(str_extract(name,\"\\\\d+\"))) |&gt;\n    select(x,y,piece=value) |&gt;\n    group_by(piece) |&gt;\n    mutate(x_min=min(x),y_min=min(y),\n           x_max=max(x),y_max=max(y),\n           idx=row_number(x+y),\n           adj_x=x-x_min+1,adj_y=y-y_min+1) |&gt;\n    ungroup()\n}\n\n### df for data frame\nsol_df &lt;- sol_df |&gt; \n  mutate(solution_df = map(X2,make_coord_df))\n\n### df_long for data frame that's unnested\nsol_df_long &lt;- sol_df |&gt; \n  unnest(solution_df)\n\n\nThe solutions are provided in a plain text file, where each solution is represented by 10 strings of characters x 6 rows for each of 2339 solutions for 6x10 rectangle. Each letter corresponds to one of the 12 pentomino pieces. Using this as input, I created a function to process each solution into a structured tibble (data frame).\n\n\nConvert to SF Object\n# Function to turn coordinate as center and conver to square\ncreate_square_fence &lt;- function(x, y) {\n  st_polygon(list(matrix(c(\n    x-0.5, y-0.5,  # Bottom Left\n    x+0.5, y-0.5, #Bottom Right\n    x+0.5, y+0.5, #Top Right\n    x-0.5, y+0.5, #Top Left\n    x-0.5, y-0.5  # Close the polygon by coming back to bottom left\n  ), ncol = 2, byrow = TRUE)))\n}\n\n### Convert data frame into sf object\nsol_sf &lt;- sol_df_long |&gt;\n  rowwise() |&gt;\n  # For each row, create a square geometry from the x, y coordinate\n  mutate(geometry=list(create_square_fence(x,y)),\n         geometry_adj=list(create_square_fence(adj_x,adj_y))) |&gt;\n  ungroup() |&gt; # Remove rowwise grouping\n  group_by(X1,piece) |&gt;\n  summarise(geometry=st_union(st_sfc(geometry)),.groups=\"drop\",\n            geometry_adj=st_union(st_sfc(geometry_adj),.groups=\"drop\")) |&gt;\n  st_sf() \n\n\npieces_63 &lt;-sol_sf |&gt;\n  st_drop_geometry() |&gt;\n  count(piece,geometry_adj,sort=T) |&gt;\n  arrange(piece) |&gt;\n  mutate(i=row_number()) |&gt;\n  mutate(col=colourvalues::color_values(i,farver::decode_colour(retro_col)))\n\nsol_sf_comb &lt;- sol_sf |&gt; \n  inner_join(pieces_63 |&gt; select(col,geometry_adj,piece))\n\n\nOnce the data frame was ready, next step was to convert it into sf geometries for spatial analysis and visualization. Here’s how I’ve tackled it.\n\nSquare Polygons: I wrote a small helper function to create a square polygon for each (x,y) coordinate. Each square represents a single unit of the pentomino square pieces.\nMerging into Shapes: To represent entire pentomino pieces, I’ve combined all individual square polygons for a piece into a single shape using st_union().\n\nNormalized Geometry for Variations:\n\n\n\nPentomino pieces can appear in up to 8 variations (rotations and flips). For example, a single piece might have multiple “faces”, depending on how it’s oriented in the solution.\nTo identify which variations of a piece was used in each solution, I created adjusted geometries by aligning the shapes relative to their bounding boxes.\n\n\n\nHeatmap of Pentomino Placement Patterns\nWith the 2339 Solutions processed and converted into geometries, I decided to analyze where each pentomino piece tends to appear on the board. The result is the heatmap you see below.\nThe code using geom_tile() to represent the frequency of each piece at each (x,y) position across all solutions. A facet is created for each pentomino piece, so we can see the pattern differences.\n\n\nHeatmap of Pentomino Placement Patterns\nsol_df_long |&gt;\n  count(x,y,piece) |&gt;\n  ggplot(aes(x=x,y=y)) +\n  geom_tile(aes(fill=n)) +\n  coord_fixed() +\n  facet_wrap(~piece) +\n  scale_fill_viridis_c(option=\"F\",trans=\"sqrt\",\"apperence\") +\n  theme_map(font_family=\"Roboto Condensed\")\n\n\n\n\n\n\n\n\n\n\nInsights from the Heatmap\n\nX Stays Central: The X-piece avoids edges entirely, sticking to the middle where it fits best.\nI Loves the Left Edges: The I-piece often hugs the edges, but there are a few spaces it avoids altogether.\nF and W Are Versatile: These flexible shapes show up all over, but slight tendency towards the center\nV and Y Favor the Edges: Their hook-like shapes are perfect for corners and boundaries.\nT Favors the Top Left: The T-piece seems to favour the top left-corner according to the heatmap.\nZ Leans Asymmetrically: Z leans to one side, and more likely to stay away from the edges.\nL Sticks to Edges: These elongated shapes often sit along the board’s boundaries, especially the bottom left.\nP and U Fits Everywhere: the P-piece slots into difference places.\n\n\n\n\nRecapping the Shapes\n\n\nPiece Shapes Recap\np_sep &lt;-pieces_63 |&gt;\n  group_by(piece) |&gt;\n  mutate(j=row_number(i)) |&gt;\n  st_sf() |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col)),color=\"#fffff3\") +\n  facet_grid(j~piece) +\n  theme_nothing()\n  #theme_minimal()\n\np_stack &lt;-pieces_63 |&gt;\n  group_by(piece) |&gt;\n  mutate(j=row_number(i)) |&gt;\n  st_sf() |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col)),color=\"#fffff3\") +\n  geom_sf_text(aes(label=piece, \n                   geometry=geometry_adj+c(0,3)),\n               family=\"American Typewriter\", size=5,\n               data = . %&gt;% filter(j==1)) +\n  facet_grid(~piece) +\n  theme_nothing() \n\np_sep + p_stack + plot_layout(ncol=1, heights=c(4,1))\n\n\n\n\n\n\n\n\n\nIn above I created a visualization to recap the 12 pentomino shapes, each column shows different variations of piece faces. There are 12 free pieces, but 63 fixed pieces.\n\n\nSome Solutions !\nSince it’s bit hard to display all the solution at once… I’ve first chosen these 12 special solutions. These 12 solutions are particularly interesting because they belong to 3 unique sets where the pieces remain in their default orientation—no flipping or rotation is required! Within each set, there are 4 solutions that differ only in the arrangement of the pieces on the board.\n\n\nSpecial 12 Solutions (3 Sets x 4 Solutions)\nsol_by_color &lt;-sol_sf_comb |&gt;\n  st_drop_geometry() |&gt;\n  group_by(X1) |&gt;\n  summarise(col_pal=paste(sort(col),collapse=\",\")) |&gt;\n  ungroup() |&gt;\n  add_count(col_pal) |&gt;\n  arrange(desc(n),col_pal) \n\nsol_sf_comb |&gt; \n  inner_join(sol_by_color) |&gt;\n  filter(n==4) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col))) +\n  facet_wrap(~X1) +\n  theme_map(font_family=\"Roboto Condensed\")\n\n\n\n\n\n\n\n\n\n\n\nAnother Special 9 Solutions (3 Sets x 3 Solutions)\nsol_sf_comb |&gt; \n  inner_join(sol_by_color) |&gt;\n  filter(n==3) |&gt;\n  arrange(col_pal) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col))) +\n  facet_wrap(~fct_inorder(factor(X1))) +\n  theme_map(font_family=\"Roboto Condensed\")\n\n\n\n\n\n\n\n\n\n\n\n180 Solutions where Pair Exists\nsol_sf_comb |&gt; \n  inner_join(sol_by_color) |&gt;\n  filter(n==2) |&gt;\n  arrange(col_pal) |&gt;\n  ggplot() +\n  geom_sf(aes(fill=I(col))) +\n  facet_wrap(~fct_inorder(factor(X1)),ncol=18) +\n  theme_nothing(font_family=\"Roboto Condensed\") \n\n\n\n\n\n\n\n\n\n\n\nWrapping Up 🎁\nVisualizing these solutions has been like uncovering hidden patterns in a puzzle. It’s been pretty fun execise learning to utilize some of function in sf packages too. And most importantly, now I have solution on my blog I can put away the actual puzzle board after the play."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Creating a Seigaha Motif with ggplot2",
    "section": "",
    "text": "The Seigaiha (青海波) motif, literally translated as “blue ocean waves” is a classic Japanese pattern used in textiles, ceramics, kimono and art. It features stylized waves created with concentric circles forming arches. I just learned that it symbolizes surges of good luck - delightful and thought great start to have it for blog post.\n\n青 = Blue\n海 = Ocean\n波 = Wave\n\nUsing ggplot2 and additional packages like ggforce and cowplot, I was able to recreate this timeless design programmatically.\n\n\nFirst need to load up the required libraries. Recently, I discovered package called annotater , which let you add annotation to the packages you use in script! It’s such a useful tool - future me (and anyone collaborating on my code) will likely thank me for using it.\n\n\nCode\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse' \nlibrary(ggforce) # Accelerating 'ggplot2'   \nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'  \nlibrary(gt) # Easily Create Presentation-Ready Display Tables \n\ncol10 &lt;- str_split(\"012a4a-013a63-01497c-014f86-2a6f97-2c7da0-468faf-61a5c2-89c2d9-a9d6e5\",\"-\")\n\ncol10_pal &lt;-str_c(\"#\",col10 |&gt; unlist())\n\n\n\n\n\nWe create a grid of coordinates to serve as the base for our motif. To archieve the characteristic offset of Seigaiha waves, we adjust the x coordinates for odd rows:\n\n\nCode\ndf &lt;- expand_grid(x = seq(-16, 16, by = 2), \n                  y = seq(-10, 10, by = 1)) |&gt;\n  arrange(y,x) |&gt;\n  mutate(y_odd=(y%%2==1)) |&gt;\n  mutate(idx=row_number()-1) |&gt;\n  mutate(x=if_else(y_odd,x+1,x))\n\n\n\n\n\nThe radii of the circles vary in five steps. It could be smaller or larger. I could’ve also add randomness to it too, but I just kept it constant for now.\n\n\nCode\nr_values &lt;- seq(0.3,1.1,length.out=5)\ndf_long &lt;- df |&gt; expand_grid(r=r_values)\n\n\ndf_long &lt;- df_long |&gt;\n  mutate(r_var=if_else(idx%%5==0,sqrt(r),r))\n\n#range(df_long$x)\n#range(df_long$y)\n\ndf_long |&gt; head() |&gt; gt()\n\n\n\n\n\n\n\n\nx\ny\ny_odd\nidx\nr\nr_var\n\n\n\n\n-16\n-10\nFALSE\n0\n0.3\n0.5477226\n\n\n-16\n-10\nFALSE\n0\n0.5\n0.7071068\n\n\n-16\n-10\nFALSE\n0\n0.7\n0.8366600\n\n\n-16\n-10\nFALSE\n0\n0.9\n0.9486833\n\n\n-16\n-10\nFALSE\n0\n1.1\n1.0488088\n\n\n-14\n-10\nFALSE\n1\n0.3\n0.3000000\n\n\n\n\n\n\n\n\n\n\nUsing geom_circle from ggforce, we layer circles over the grid. We map the fill colour to the adjusted radius (r_var) for a slight gradeient effect:\n\n\nCode\ndf_long |&gt;\n  arrange(-y, idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(\n    aes(\n      x0 = x,\n      y0 = y,\n      r = r,\n      fill = r_var ## just wanted to give bit of variance\n    ),\n    linewidth = 0.1,\n    color = \"#fffff3de\",\n    linetype = 3\n  ) +\n  coord_fixed(clip = \"on\",\n              xlim = c(-15, 14.5),\n              ylim = c(-9, 9)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors = col10_pal) +\n  scale_color_gradientn(colors = col10_pal)\n\n\n\n\n\n\n\n\n\n\n\n\nThe theme_nothing() from cowplot removes all unnecessary visual elements (axes, labels etc.), leaving only the motif. I’ve adjusted xlim and ylim so that I’m clipping out the extra circles."
  },
  {
    "objectID": "posts/post-with-code/index.html#seigaiha-青海波",
    "href": "posts/post-with-code/index.html#seigaiha-青海波",
    "title": "Creating a Seigaha Motif with ggplot2",
    "section": "",
    "text": "The Seigaiha (青海波) motif, literally translated as “blue ocean waves” is a classic Japanese pattern used in textiles, ceramics, kimono and art. It features stylized waves created with concentric circles forming arches. I just learned that it symbolizes surges of good luck - delightful and thought great start to have it for blog post.\n\n青 = Blue\n海 = Ocean\n波 = Wave\n\nUsing ggplot2 and additional packages like ggforce and cowplot, I was able to recreate this timeless design programmatically.\n\n\nFirst need to load up the required libraries. Recently, I discovered package called annotater , which let you add annotation to the packages you use in script! It’s such a useful tool - future me (and anyone collaborating on my code) will likely thank me for using it.\n\n\nCode\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse' \nlibrary(ggforce) # Accelerating 'ggplot2'   \nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'  \nlibrary(gt) # Easily Create Presentation-Ready Display Tables \n\ncol10 &lt;- str_split(\"012a4a-013a63-01497c-014f86-2a6f97-2c7da0-468faf-61a5c2-89c2d9-a9d6e5\",\"-\")\n\ncol10_pal &lt;-str_c(\"#\",col10 |&gt; unlist())\n\n\n\n\n\nWe create a grid of coordinates to serve as the base for our motif. To archieve the characteristic offset of Seigaiha waves, we adjust the x coordinates for odd rows:\n\n\nCode\ndf &lt;- expand_grid(x = seq(-16, 16, by = 2), \n                  y = seq(-10, 10, by = 1)) |&gt;\n  arrange(y,x) |&gt;\n  mutate(y_odd=(y%%2==1)) |&gt;\n  mutate(idx=row_number()-1) |&gt;\n  mutate(x=if_else(y_odd,x+1,x))\n\n\n\n\n\nThe radii of the circles vary in five steps. It could be smaller or larger. I could’ve also add randomness to it too, but I just kept it constant for now.\n\n\nCode\nr_values &lt;- seq(0.3,1.1,length.out=5)\ndf_long &lt;- df |&gt; expand_grid(r=r_values)\n\n\ndf_long &lt;- df_long |&gt;\n  mutate(r_var=if_else(idx%%5==0,sqrt(r),r))\n\n#range(df_long$x)\n#range(df_long$y)\n\ndf_long |&gt; head() |&gt; gt()\n\n\n\n\n\n\n\n\nx\ny\ny_odd\nidx\nr\nr_var\n\n\n\n\n-16\n-10\nFALSE\n0\n0.3\n0.5477226\n\n\n-16\n-10\nFALSE\n0\n0.5\n0.7071068\n\n\n-16\n-10\nFALSE\n0\n0.7\n0.8366600\n\n\n-16\n-10\nFALSE\n0\n0.9\n0.9486833\n\n\n-16\n-10\nFALSE\n0\n1.1\n1.0488088\n\n\n-14\n-10\nFALSE\n1\n0.3\n0.3000000\n\n\n\n\n\n\n\n\n\n\nUsing geom_circle from ggforce, we layer circles over the grid. We map the fill colour to the adjusted radius (r_var) for a slight gradeient effect:\n\n\nCode\ndf_long |&gt;\n  arrange(-y, idx, desc(r)) |&gt;\n  ggplot() +\n  geom_circle(\n    aes(\n      x0 = x,\n      y0 = y,\n      r = r,\n      fill = r_var ## just wanted to give bit of variance\n    ),\n    linewidth = 0.1,\n    color = \"#fffff3de\",\n    linetype = 3\n  ) +\n  coord_fixed(clip = \"on\",\n              xlim = c(-15, 14.5),\n              ylim = c(-9, 9)) +\n  theme_nothing() +\n  scale_fill_gradientn(colors = col10_pal) +\n  scale_color_gradientn(colors = col10_pal)\n\n\n\n\n\n\n\n\n\n\n\n\nThe theme_nothing() from cowplot removes all unnecessary visual elements (axes, labels etc.), leaving only the motif. I’ve adjusted xlim and ylim so that I’m clipping out the extra circles."
  },
  {
    "objectID": "posts/pentomino/index.html",
    "href": "posts/pentomino/index.html",
    "title": "What’s a Pentomino Anyway?",
    "section": "",
    "text": "Pakcages Used in This Blog Post\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse'\nlibrary(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'\nlibrary(sf) # Simple Features for R\nlibrary(patchwork) # The Composer of Plots\n\n\n\nPentominos?\nWhen I was a kid, my dad made a wooden pentomino puzzle which I don’t remember actually solving it (oops!). Many years later, he recreated it with a 3D printer, and while it’s now a plastic version, my puzzle-solving skills haven’t improved much. Whenever I try to put it away, I find myself searching the internet for solutions. So, I thought—why not save some solutions on my blog? BUT, instead of just posting them, I decided to bring pentominos in R to play around.\n\n\nWhat are Pentominos anyway?\nPentominoes are geometric puzzles made up of 12 unique shapes, each consisting of exactly five connected squares. The name comes from the Greek root “penta”, meaning five. The well known Domino 🁓 is 2 connected squares!\nEach piece is named after the letter it resembles—like F, L, T, and Z. The challenge? Fit these pieces together to cover a rectangular board (or other shapes) without overlaps or gaps.\nHere’s a look at the 12 pentomino pieces: \n\n\nCreation of Pentomino Tibble\nBelow is the script to create pentomino_df. Essentially I just recorded coordinates where I should draw a square, so that I can easily draw pentomino pieces with geom_tile function with ggplot2 later!\n\n\nCreation of Individual Pieces as Tibble\nretro_col5 &lt;- c(\"#00A0B0\", \"#6A4A3C\", \"#CC333F\", \"#EB6841\", \"#EDC951\")\n\npentomino_pieces &lt;- list(\n  F = list(c(0,0), c(0,1), c(1,1), c(1,2), c(2,1)),\n  I = list(c(0,0), c(1,0), c(2,0), c(3,0), c(4,0)),\n  L = list(c(0,0), c(1,0), c(2,0), c(3,0), c(3,1)),\n  N = list(c(0,0), c(1,0), c(2,0), c(2,1), c(3,1)),\n  P = list(c(0,0), c(0,1), c(1,0), c(1,1), c(0,2)),\n  T = list(c(0,0), c(0,1), c(0,2), c(1,1), c(2,1)),\n  U = list(c(0,0), c(1,0), c(2,0), c(0,1), c(2,1)),\n  V = list(c(0,0), c(1,0), c(2,0), c(2,1), c(2,2)),\n  W = list(c(0,2), c(1,1), c(1,2), c(2,1), c(2,0)),\n  X = list(c(0,1), c(1,1), c(1,0), c(1,2), c(2,1)),\n  Y = list(c(0,0), c(1,0), c(2,0), c(3,0), c(2,1)),\n  Z = list(c(0,2), c(1,2), c(1,1), c(1,0), c(2,0))\n)\n\n# Convert pentomino pieces into a tibble\npentomino_df &lt;- tibble(\n  piece = names(pentomino_pieces),\n  coords = pentomino_pieces\n) %&gt;%\n  unnest(coords) %&gt;%  # Expand list of coordinates into rows\n  mutate(\n    x = map_dbl(coords, ~ .x[1]),  # Extract x coordinate\n    y = map_dbl(coords, ~ .x[2])   # Extract y coordinate\n  ) %&gt;%\n  select(-coords)  # Remove the original list column\n\n# Assign symmetry type to pieces \npentomino_df &lt;- pentomino_df |&gt;\n  mutate(rotate_options = \n           case_when(piece %in% c(\"X\") ~ 1,\n                     piece %in% c(\"I\") ~ 2,\n                     piece %in% c(\"Z\") ~ 2,\n                     piece %in% c(\"T\",\"U\",\"V\",\"W\") ~ 2,\n                     piece %in% c(\"F\",\"L\",\"N\",\"P\",\"Y\") ~ 4),\n         flip_options = case_when(piece %in% c(\"F\",\"L\",\"N\",\"P\",\"Y\",\"Z\") ~ 2,\n                                  TRUE ~ 1)) |&gt;\n  mutate(group_name = \n           case_when(piece %in% c(\"X\") ~ \"multi-axis\",\n                     piece %in% c(\"I\") ~ \"line-point\",\n                     piece %in% c(\"Z\") ~ \"point\",\n                     piece %in% c(\"T\",\"U\",\"V\",\"W\") ~ \"line\",\n                     piece %in% c(\"F\",\"L\",\"N\",\"P\",\"Y\") ~ \"none\"))\n\n\nWhat’s the use of dataset, if you don’t visualize them? ;)\n\n\nVisualzing Each Pieces with ggplot2\n### using geom_tile to visualize\npentomino_df |&gt;\n  group_by(piece) |&gt;\n  ### I just want to give different color to each square \n  mutate(idx=row_number(x)) |&gt;\n  ggplot(aes(x=x,y=y)) +\n  geom_tile(aes(fill=factor(idx)), color=\"white\") +\n  geom_text(aes(label=str_c(piece,\"\\nsym:\",group_name)),\n            data = . %&gt;% \n              group_by(group_name,piece) %&gt;%\n              summarise(x=max(x)+0.5, y=max(y+1.5)), \n            hjust=1,vjust=1,\n            lineheight=0.8, family=\"Roboto Condensed\") +\n  facet_wrap(~piece+group_name) +\n  scale_fill_manual(values=retro_col5) +\n  theme_nothing() +\n  coord_fixed()  +\n  theme(plot.background=element_rect(fill=\"#fffff3\", color=\"#fffff300\"))\n\n\n\n\n\n\n\n\n\n\n\nFrom Blocks to Geometry: Converting Pentominoes into Spatial Data\nWhen working with spatial data, converting objects into simple features opens up possibilities for spatial analysis and visualization. The sf package in R provides a user-friendly and standardized way to handle geometric shapes and spatial attributes.\nSimple features represent spatial data as geometries (like points, lines, and polygons) alongside their associated attributes. So here’s how I’ve converted data frame with 60 rows into 12 rows with geometry column.\n\n\nCreating sf object\n# Function to create a square polygon from a coordinate\n# Each coordinate represents the bottom-left corner of a square\ncreate_square &lt;- function(x, y) {\n  st_polygon(list(matrix(c(\n    x, y,  # Bottom Left\n    x + 1, y, #Bottom Right\n    x + 1, y + 1, #Top Right\n    x, y + 1, #Top Left\n    x, y  # Close the polygon by coming back to bottom left\n  ), ncol = 2, byrow = TRUE)))\n}\n\n# Step-by-step process to convert pentomino data into an sf object\npentomino_sf &lt;- pentomino_df |&gt;\n  rowwise() |&gt;\n  # For each row, create a square geometry from the x, y coordinate\n  mutate(geometry=list(create_square(x,y))) |&gt;\n  ungroup() |&gt; # Remove rowwise grouping\n  group_by(piece) |&gt;\n  # Group all square geometries for each pentomino piece into a single shape\n  summarise(geometry=st_union(st_sfc(geometry)),.groups=\"drop\") |&gt;\n  # Convert the summarised data into an sf object\n  st_sf() \n\n# Write it out as geojson for future use\n#pentomino_sf |&gt; \n  #st_write(fs::path(here::here(),\"posts\",\"pentomino\",\"pentomino_sf.geojson\"))\n\npentomino_sf \n\n\nSimple feature collection with 12 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 0 ymin: 0 xmax: 5 ymax: 3\nCRS:           NA\n# A tibble: 12 × 2\n   piece                                                            geometry\n   &lt;chr&gt;                                                           &lt;POLYGON&gt;\n 1 F     ((0 0, 0 1, 0 2, 1 2, 1 3, 2 3, 2 2, 3 2, 3 1, 2 1, 1 1, 1 0, 0 0))\n 2 I     ((0 1, 1 1, 2 1, 3 1, 4 1, 5 1, 5 0, 4 0, 3 0, 2 0, 1 0, 0 0, 0 1))\n 3 L     ((0 1, 1 1, 2 1, 3 1, 3 2, 4 2, 4 1, 4 0, 3 0, 2 0, 1 0, 0 0, 0 1))\n 4 N     ((0 1, 1 1, 2 1, 2 2, 3 2, 4 2, 4 1, 3 1, 3 0, 2 0, 1 0, 0 0, 0 1))\n 5 P               ((0 1, 0 2, 0 3, 1 3, 1 2, 2 2, 2 1, 2 0, 1 0, 0 0, 0 1))\n 6 T     ((0 0, 0 1, 0 2, 0 3, 1 3, 1 2, 2 2, 3 2, 3 1, 2 1, 1 1, 1 0, 0 0))\n 7 U     ((0 1, 0 2, 1 2, 1 1, 2 1, 2 2, 3 2, 3 1, 3 0, 2 0, 1 0, 0 0, 0 1))\n 8 V     ((0 1, 1 1, 2 1, 2 2, 2 3, 3 3, 3 2, 3 1, 3 0, 2 0, 1 0, 0 0, 0 1))\n 9 W     ((3 0, 2 0, 2 1, 1 1, 1 2, 0 2, 0 3, 1 3, 2 3, 2 2, 3 2, 3 1, 3 0))\n10 X     ((2 0, 1 0, 1 1, 0 1, 0 2, 1 2, 1 3, 2 3, 2 2, 3 2, 3 1, 2 1, 2 0))\n11 Y     ((0 1, 1 1, 2 1, 2 2, 3 2, 3 1, 4 1, 4 0, 3 0, 2 0, 1 0, 0 0, 0 1))\n12 Z     ((1 1, 1 2, 0 2, 0 3, 1 3, 2 3, 2 2, 2 1, 3 1, 3 0, 2 0, 1 0, 1 1))\n\n\n\nPlotting SF Object with geom_sf\nNow that I’ve transformed my pentomino shapes into sf objects, it’s time to explore the magical world of geometric unary operations! Unary operation is an operation that acts on a single geometric shape to derive a new geometry.\nIn below, I’m playing around with visualizing my pentomino pieces in layers. Each layer has its own unique touch, an inflated buffer, a deflated outline, as well as the original piece.\nColour of pieces are separated by sysmetry groups. FLNPY pieces are asymetric pieces, while TUVW has line symmetry and so on.\n\n\nPlotting SF object with geom_sf\n# Quickly Plotting Out with geom_sf\npentomino_sf |&gt;\n  left_join(pentomino_df |&gt; select(piece,group_name)) |&gt;\n  ggplot() +\n  ### puffing it with bigger positive number\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=1)),\n          alpha=0.05, color=\"snow\") +\n  ### puffing the geometry by 0.25 to give them little bubble\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=0.25)),\n          alpha=0.3) +\n  ### original shape of pentomino pieces\n  geom_sf(aes(fill=group_name),color=\"white\") +\n  ### deflating just a bit and making it look like stiches\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=-0.2)),\n          color=\"white\",linetype=3) +\n  ### deflating closer to the core\n  geom_sf(aes(fill=group_name,\n              geometry=st_buffer(geometry,dist=-0.45)),\n          color=\"white\",linetype=1) +\n  facet_wrap(~piece) +\n  scale_fill_manual(values=retro_col5) +\n  theme_minimal_grid(font_family=\"Roboto Condensed\") +\n  labs()\n\n\n\n\n\n\n\n\n\n\n\nUsing Minimum Rotated Rectangle\nNext up, I just decide to wrap each pentomino in its neatest, smallest rectangle. This is if I were to wrap each pieces in gift wrap. 🎁 The number displayed is the area of rectangle.\nThese rectangles reveal how tightly we can enclose shapes, which is useful in applications like spatial optimization or determining object orientation in real-life scenario.\n\n\nUsing st_minimum_rotate_rectangle\n# Rotate x degrees around (0,0)\nrot &lt;- function(a) {\n  a = a*(pi/180)\n  matrix(c(cos(a), sin(a), -sin(a), cos(a)), 2, 2)\n}\n\n# Visualize pentomino pieces with their minimum rotated rectangles\nbox_me_up &lt;- function(angle,...) {\n  pentomino_sf |&gt;\n  mutate(geometry=geometry*rot(angle)) |&gt; \n  mutate(mrr_area = st_area(st_minimum_rotated_rectangle(geometry))) |&gt;\n  left_join(pentomino_df |&gt; select(piece,group_name)) |&gt;\n  ggplot() +\n  # Plot rotated rectangles around each shape\n  geom_sf(aes(fill=factor(mrr_area),\n              geometry=st_minimum_rotated_rectangle(geometry)),\n          alpha=0.1,linetype=3, color=\"black\") +\n  # Plot original pentomino shapes \n  geom_sf(aes(fill=factor(mrr_area)),color=\"white\",alpha=0.9) +\n  geom_sf_text(aes(label=mrr_area), family=\"Roboto Condensed\") +\n  facet_wrap(~piece) +\n  scale_fill_manual(values=c(retro_col5,\"#56B870\"),guide=\"none\") +\n  theme_minimal_grid(font_family=\"Roboto Condensed\") +\n  labs(title=str_glue(\"{angle} degree rotated\")) +\n  theme(text=element_text(family=\"Roboto Condensed\"),\n        axis.text=element_blank()) +\n    labs(x=\"\",y=\"\")\n}\n\n\np1 &lt;- box_me_up(90)\np2 &lt;- box_me_up(180)\n\np1 + p2\n\n\n\n\n\n\n\n\n\nAt first, it seemed strange that the F-shape’s rotated rectangle has an area of 9.6, while a simple grid-aligned box could enclose it in an area of 9. The st_minimum_rotated_rectangle function looks for the tightest-fitting rectangle that can enclose the shape. It doesn’t stick to the grid - instead, it tilts the rectangle to snugly fit the shape, even if the result feels counterintuitive? (At least I thought it was counterintuitive…)\n\n\n\nWhere’s the Solutions?\nFor now, I’m wrapping up my geometry experiments (pun intended 🎁).\nI’ll dive into how to fit these pieces together to solve the classic pentomino puzzles - No more googling for a solution in next post."
  },
  {
    "objectID": "posts/2024_12/taco_hat_cake_gift_pizza.html",
    "href": "posts/2024_12/taco_hat_cake_gift_pizza.html",
    "title": "Recreating the Chaos of Taco Hat Cake Gift Pizza in R",
    "section": "",
    "text": "🌮🎩🍰🎁🍕 Taco Hat Cake Gift Pizza with Monkey, Ninja, and Unicorn\nOver the Christmas holiday, my niece and nephew introduced me to Taco Cat Goat Cheese Pizza, a game that’s equal parts chaotic and hilarious. Imagine trying to slap a card while screaming “TACO!” but your hand freezes like it forgot its job. 🖐️🌮\nMy niece and nephew absolutely crushed me — I like to blame that I’ve had one too many cookies and was too slow 🍪🍫🍷.\nBut even in defeat, I had so much fun that I decided I needed a version of this game at home. So, I went ahead and bought Taco Hat Cake Gift Pizza (because, let’s be honest, who can resist a ninja 🥷 and unicorn 🦄?).\n\n\nCrafting the Card Deck\n\n\nPakcages Used in This Blog Post\nlibrary(tidyverse) # Easily Install and Load the 'Tidyverse'\nlibrary(ggforce) # Accelerating 'ggplot2'\nlibrary(ggtext) # Improved Text Rendering Support for 'ggplot2'\nlibrary(ggimage) # Use Image in 'ggplot2'\nlibrary(fs) # Cross-Platform File System Operations Based on 'libuv'\n\n\nWhen I opened the game, I found myself fascinated by the simple yet clever design of the card deck. It’s a perfect balance of “base” cards (like Taco, Hat, Cake, Gift, and Pizza) and “special” cards (Monkey, Unicorn and Ninja). Naturally, my data-nerd instincts kicked in, and I thought: Why not recreate this deck as a dataset in R?\nUsing the tidyverse, I created a small dataset to represent the deck. Instead of manually duplicating rows to match the card counts, I used one of my favorite hidden gems in tidyverse: uncount() in tidyr package.\n\n\nCreation of the Card Deck\n# Define the palette\npal5 &lt;- c(taco=\"#2f4858\",hat=\"#33658a\",cake=\"#86bbd8ff\",pizza=\"#f6ae2dff\",gift=\"#f26419\")\nbase_img_path &lt;- path(here::here(),\"posts\",\"2024_12\",\"images\")\n\n# Sample card composition data\ncards_comp &lt;- tibble(\n  card = c(\"Taco\", \"Hat\", \"Cake\", \"Gift\", \"Pizza\", \"Monkey\", \"Ninja\", \"Unicorn\"),\n  emoji = c(\"🌮\", \"🎩\", \"🍰\", \"🎁\", \"🍕\", \"🐵\", \"🥷\", \"🦄\"),\n  emoji_img = c(taco=path(base_img_path,\"taco.png\"),\n                hat=path(base_img_path,\"hat.png\"),\n                cake=path(base_img_path,\"cake.png\"),\n                gift=path(base_img_path,\"gift.png\"),\n                pizza=path(base_img_path,\"pizza.png\"),\n                monkey=path(base_img_path,\"monkey.png\"),\n                ninja=path(base_img_path,\"ninja.png\"),\n                unicorn=path(base_img_path,\"unicorn.png\")),\n  type = c(rep(\"base\",times=5),rep(\"special\",times=3)),\n  count = c(11,11,11,11,11,3,3,3)\n)\n\n###. Here's the power of Uncount function, opposite of dplyr::count()\ncards &lt;- cards_comp |&gt; uncount(count)\n\n### After cards have been unnested, assigning background color\ncards$color &lt;- c(rep(pal5[\"taco\"],times=8),c(pal5[c(\"pizza\",\"gift\",\"hat\")]),\n          rep(pal5[\"hat\"],times=9),c(pal5[c(\"taco\",\"cake\")]),\n          rep(pal5[\"cake\"],times=8),c(pal5[c(\"taco\",\"gift\",\"hat\")]),\n          rep(pal5[\"gift\"],times=8),c(pal5[c(\"pizza\",\"taco\",\"pizza\")]),\n          rep(pal5[\"pizza\"],times=8),c(pal5[c(\"hat\",\"taco\",\"gift\")]),\n          c(pal5[c(\"gift\",\"pizza\",\"hat\")]),\n          c(pal5[c(\"hat\",\"pizza\",\"taco\")]),\n          c(pal5[c(\"taco\",\"cake\",\"hat\")])) \n\n\n\nSpotlight on uncount()\nIf you’ve ever struggled to expand a dataset by repeating rows based on a count column, uncount() is a lifesaver. In just one line, it takes a column like count and automatically duplicates rows the specified number of times. I actually didn’t know this function till fairly recently.\n\n\n\nVisualizing the Card Composition\nWith the deck dataset ready, I couldn’t resist visualizing it. Using ggplot2 and ggimage, I created a colorful layout that shows the composition of cards in Taco Hat Cake Gift Pizza.\nHere’s the plot:\n\n\nLayout Out Base & Special Card\ncards |&gt;\n  arrange(type) |&gt;\n  #slice_sample(n = nrow(cards)) |&gt;\n  #mutate(player=c(rep(c(\"A\",\"B\",\"C\",\"D\",\"E\"),times=12),\"X\",\"X\",\"X\",\"X\")) |&gt;\n  mutate(grp=if_else(type==\"base\",card,type)) |&gt;\n  mutate(grp=fct_inorder(grp)) |&gt;\n  group_by(grp) |&gt;\n  mutate(idx=row_number()) |&gt;\n  ggplot(aes(x=idx,y=grp)) +\n  geom_tile(aes(fill=I(color)), width=0.75, height=0.97) +\n  geom_image(aes(image=emoji_img, by=\"height\"), size=0.1) +\n  coord_fixed() +\n  theme_nothing(base_family=\"Roboto Condensed\") +\n  geom_richtext(aes(x=0,y=grp,\n                    label=str_glue(\"&lt;b&gt;{n}&lt;/b&gt;&lt;br&gt;{grp}&lt;br&gt;cards\")),\n                data = . %&gt;% group_by(grp) %&gt;% summarise(n=n(),det=paste(unique(card),collapse=\"&lt;br&gt;\")),\n                family=\"Roboto Condensed\",\n                fill=\"transparent\",\n                label.colour=\"transparent\") +\n  labs(title=\".    Composition of Cards inside of Taco Hat Cake Gift Pizza\")\n\n\n\n\n\n\n\n\n\n\n\nShuffling the Deck and Dealing to Players 🎲\nOnce the deck was ready, it was time to shuffle and deal. After all, what’s a card game without a bit of randomness? Using slice_sample(), I shuffled the cards, then distributed them to five imaginary players.\nHere’s how the shuffled cards looked when dealt out, with any extra cards forming a “Left Over Pile”:\n\n\nShuffling and Dealing\n# Shuffle the cards\nshuffled_cards &lt;- cards |&gt; \n  slice_sample(n = nrow(cards))\n\nplayer_num &lt;- 5\nshuffled_cards |&gt;\n  mutate(idx=row_number()-1,\n         player = (idx%%player_num)+1) |&gt;\n  mutate(is_left_over=idx&gt;=player_num*12) |&gt;\n  mutate(player=if_else(is_left_over,\"Left Over Pile\",str_c(\"Player \",player))) |&gt;\n  ggplot(aes(x=idx%%4,y=floor((idx%%12)/4))) +\n  geom_tile(aes(fill=I(color)),width=0.97, height=0.97) +\n  geom_image(aes(image=emoji_img, by=\"height\"), size=0.12) +\n  theme_nothing(base_family=\"Roboto Condensed\") +\n  facet_wrap(~player)\n\n\n\n\n\n\n\n\n\n\n\nFinal Thoughts\nRecreating Taco Hat Cake Gift Pizza in R was a fun way to blend coding with a bit of chaos. From shuffling cards to imagining new twists, this exercise now sparked few different ideas on how to utilize this mini dataset — and maybe a few new rules for game night. 🌮🎩🍰"
  },
  {
    "objectID": "posts/2024_12/geometric_pattern_ggplot.html",
    "href": "posts/2024_12/geometric_pattern_ggplot.html",
    "title": "Geometic Art Generator with Shiny",
    "section": "",
    "text": "🌟 Introduction\nggplot2—the trusty workhorse of R. It’s definitely have been the go-to package for creating stunning visualizations for years. And it’s not going anywhere anytime soon. 🎉\nBut I’ve always wondered: What if my ggplot2 creations could come to life? What if I could tweak a slider and instantly see my charts morph? Enter Shiny—a magical tool to make R interactive.\nI procrastinated for years. I finally jumped in. Thanks to tools like shinyapps.io and shinythemes, the process was much smoother than I imagined. These tools took away the stress of deployment and styling, making Shiny approachable even for a beginner like me.\n\n\n🎨 Geometric Generative Art - Shiny App Experimentation\n\n\nCode\ngraph LR\n    A[Static ggplot2 Plot] --&gt; B[Dynamic Shiny App]\n    B --&gt; C[Published on shinyapps.io]\n    C --&gt; D[Embedded in Blog Post]\n\n\n\n\n\ngraph LR\n    A[Static ggplot2 Plot] --&gt; B[Dynamic Shiny App]\n    B --&gt; C[Published on shinyapps.io]\n    C --&gt; D[Embedded in Blog Post]\n\n\n\n\n\n\nTo dip my toes into Shiny, I created an app that lets you experiment with geometric generative art. Adjust sliders to tweak parameters like rotation, scale, and color, and transformation on coordinate system to see how patterns come to life in real time!\n\n\n\n\n\n\nThis app is more of a personal playground for exploring patterns than a polished product. Feel free to experiment!\n\n\n\n\n\n\n\n🎥 From Interactivity to Animation\nAs I played with the app, I wanted to see how parameter changes would look as a sequence. I automated the process to generate frames and stitched them into this animated gif:\n\n\n\n\n✍️ Key Takeaways\nShiny brings interactivity to static ggplot2 visualizations—perfect for both data exploration and presentation.\nTools like shinyapps.io and shinythemes make the process approachable and stylish! I’ve also started exploring newer options like bslib and thematic, which seem promising for even more customization and polished visuals. ✨\nThis one’s probably obvious to seasoned Shiny users. But for me, it was a total lightbulb 💡 moment. Decoupling Shiny app development from the blog itself made everything so much easier, and I wish I’d known this sooner!\nStart with something fun to learn Shiny—because jumping straight into building a business dashboard feels like a much higher hurdle. Experimenting with something playful, like geometric art, makes the learning curve way less intimidating."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CHI(χ)-Files",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nPentomino Solutions 6x10 Rectangle\n\n\n\n\n\n\nJanuary 9, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nWhat’s a Pentomino Anyway?\n\n\n\n\n\n\nJanuary 7, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nRecreating the Chaos of Taco Hat Cake Gift Pizza in R\n\n\n\n\n\n\nJanuary 4, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing 445 Calendar in R\n\n\n\n\n\n\nDecember 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGeometic Art Generator with Shiny\n\n\n\n\n\n\nDecember 26, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nFish-Eye Lens Effect with ggplot2\n\n\n\n\n\n\nDecember 22, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nCreating a Seigaha Motif with ggplot2\n\n\n\n\n\n\nDecember 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHello World! The First Post!\n\n\nAn introduction to the Chi-Files blog and its exciting journey trying to learn Quarto.\n\n\n\nDecember 21, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  }
]